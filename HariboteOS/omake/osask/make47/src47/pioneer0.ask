/* "pioneer0":ぐいぐいの標準ライブラリ ver.3.7
    copyright(C) 2005 H.Kawai (川合秀実), I.Tak., KIYOTO */

/* これは、アプリケーションを書きやすくするための各種サービスを提供するプログラム。
   結局のところ、処理をshellcallに取り次いでいるだけ。
   shellcallの仕様は流動的なので、このライブラリがその変化を吸収しているともいえる。 */

/* スタックは1KBくらいあれば問題は無いだろう。 */

#include "osaskinc.ask"

segment CODE(USE32, PARA);
default(code == CODE);
default(data == CODE);

#define SAFEAPI_FLAG 2

#if (defined(SAFEAPI_FLAG))
	void signal_cut_mode();
	/* 一文ではないので、if文などでは{}で括るのを忘れずに */
	#define SAFE_CUT(msg)	signal_cut_mode(); asmout(msg);
#else
	#define SAFE_CUT(msg)	INT(0x03)
#endif
/* softint禁止の関係で、SAFE_CUTできない場合 */
#define SAFE_CUT0(msg)	INT(0x03)

#if (defined(WIN9X))
	#define	DEFAULT_TBOX_BCOL	8

#elif (defined(TMENU))
	#define DEFAULT_TBOX_BCOL	15

#elif (defined(CHO_OSASK))
	#define DEFAULT_TBOX_BCOL	8

#elif (defined(NEWSTYLE))
	#define DEFAULT_TBOX_BCOL	8

#elif (defined(WIN31))
	#define	DEFAULT_TBOX_BCOL	15

#endif

struct WORK { /* 256bytes */
	char signature[8]; int children_back, children_next;
	int softint_EIP, softint_CS, nest /* user用 */, read_ptr /* system用 */;
	int softint_ret_buf[16], softint_mask_buf[16]; /* system用 */
	int signalbox_read_free, signalbox_eos, signalbox_rewind, signaldw /* user用 */;
	int signalbox_write_free, signalbox_write_ptr,
		signalbox_write_ptr0, signalbox_write_ptr1; /* user用 */
	char signalbox_status, ending_count, [14];
	/* 空きは144バイト */
};

struct WINDOW {	/* 128bytes */
	char signature[8];
	int chain_back, chain_next;
	int children_back, children_next;
	int x_size, y_size, x_ofs, y_ofs;
	int slot;
	unsigned char mode0, draw_enable, siglen, sigflag;
	int signalhead[16];
	unsigned char flags; /* bit3:frame only */
	/* 空きは63バイト */
};
/* closetextbox/コンポーネントの描画を抑制した。コンポーネントにも付けるフラグ */
#define WINFLAG_MUSTREDRAW	1
/* drawblockが実行されたが描画を抑制した。*/
#define WINFLAG_DIRTYGBOX	2
/* title色が変わった */
#define WINFLAG_TITLE		4
/* ウィンドウがコンポーネントで一杯なので枠しか描画しない */
#define WINFLAG_FRAMEONLY	8
/* ユーザがウィンドウ全体を自力で描画するので↑の判定をしない */
#define WINFLAG_USERCONTROL	16

struct TEXTBOX { /* 64bytes */
	char signature[8];
	int chain_back, chain_next;
	int x_size, y_size, x0, y0;
	int option, backcolor, charset, window;
	int blank;
	char flags;
	void [11]; /* 空きは11バイト */
	int buffer[0];
};

struct GRAPHBOX { /* 64bytes */
	char signature[8];
	int chain_back, chain_next;
	unsigned char mode, [1], flags, [1];
	int mode_opt, x_bsize, y_bsize; /* バッファ属性(これはユーザーが管理する) */
	int x_vsize, y_vsize, x0, y0; /* 表示上の属性(これもユーザーが管理する) */
	int window, vbuf0, vx0, vy0;
	int buffer[0];
};

void drawcomponent();
void drawwindow();
void drawwindow_back();
void drawwindow_frame();
void textbox_drawback(); /* テキストボックスの背景描画ルーチン */
void lineconv();
void sendusersignal();
void titlebox_redraw();

/*
	スロットの使用状況
		0x0000〜0x0170 : shell-call側でリザーブ
		0x01c0〜0x01e0 : システムタイマー
		0x01f0         : pioneerのワークエリア位置などを保存
		0x0200〜0x03f0 : ユーザーに解放
*/

void far pioneer0()
/* Lv3のライブラリー
   セグメントは、DS == FS == SSである事を仮定している。
   コマンドはDS:EBX以降に格納されている。 */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	PUSHAD();
	(offset) cmd = EBX;
	CMP(cmd[0], 0x0004);
	asmout("JE cmd004");
	/* 最初のコマンドが初期化コマンドではない */

	EBX = 0xffffffff;
	EAX = 0x0004; /* read user-slot command */
	ECX = 0x01f0; /* スロット番号(pioneerワークスロット) */
	CALL(0x0017,0); /* shell-call */
	(offset) work = EDX;

	/* softint禁止 */
	LEA(EBX, work->softint_mask_buf[0]); /* add_nest */
//	work->softint_mask_buf[ 8] = 0xff80; /* (Llv変更しない) */
	(int) [DS:EBX + 8] = 0xff80;
	CALL(0x0017,0); /* shell-call(softint抑制) */

asmout("nextcmd: equ $");
	EAX = cmd[0];
	if ((unsigned) EAX < 0x0130) {
		TEST(EAX, 0x03);
		if (== 0)
			asmout("JMP DWORD CS:[EAX+.cmd_jumptable]");
	}

	/* コマンド番号エラー
	   EAX    受理されなかったコマンド番号
	   DS:ESI そのコマンドへのポインタ */

cmderr:
	LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更しない) */
	CALL(0x0017,0); /* shell-call(softint許可) */
	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;
	SAFE_CUT("DB ..$-$-1,'Invalid command ',0,'@',6,'.'");
//	TEST(ESP, ESP); // ZF = 0
	POPAD();
	return;

	ALIGN(4);
cmd_jumptable:
	asmout("DD cmd000,  .cmderr, cmd008,  cmd00c ");
	asmout("DD cmd010,  cmd014,  cmd018,  cmd01c ");
	asmout("DD cmd020,  cmd024,  cmd028,  cmd02c ");
	asmout("DD cmd030,  cmd034,  .cmderr, cmd03c ");
	asmout("DD cmd040,  cmd044,  cmd048,  cmd04c ");
	asmout("DD cmd050,  cmd054,  cmd058,  cmd05c ");
	asmout("DD cmd060,  .cmderr, cmd068,  cmd06c ");
	asmout("DD cmd070,  cmd074,  cmd078,  cmd07c ");
	asmout("DD cmd080,  cmd084,  .cmderr, cmd08c ");
	asmout("DD .cmderr, .cmderr, .cmderr, .cmderr");
	asmout("DD cmd0a0,  .cmderr, cmd0a8,  cmd0ac ");
	asmout("DD cmd0b0,  .cmderr, .cmderr, .cmderr");
	asmout("DD cmd0c0,  cmd0c4,  cmd0c8,  .cmderr");
	asmout("DD cmd0d0,  .cmderr, .cmderr, .cmderr");
	asmout("DD cmd0e0,  cmd0e4,  cmd0e8,  cmd0ec ");
	asmout("DD cmd0f0,  .cmderr, .cmderr, .cmderr");
	asmout("DD .cmderr, .cmderr, cmd108,  cmd10c ");
	asmout("DD cmd050,  cmd114,  cmd118,  .cmderr");
	asmout("DD cmd120,  .cmderr, .cmderr, .cmderr");
}

void far cmd000()
/* 終了コマンド */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;

	/* 待機中の割り込みを検査 */
	if (work->nest == 0) { /* 割り込みはマスクされていない */
		if (work->signalbox_read_free != 0) { /* バッファにシグナルがある */
			PUSH(EAX); /* ESP -= 4;の代わり */
			if ((unsigned) (int) [SS:ESP + 16 /* ESP */] != 1) {
				/* ハンドラからの帰還要求は出ていない */

				/* 新規割り込み
				   スタックの積み替え

				 <積み替え後のスタック構成>
				   +0 〜  +31 : PUSHADイメージ
				  +32 〜  +43 : EIP, CS, EFLAGS
				  +44 〜  +59 : ES, DS, FS, GS
				  +60 〜  +91 : PUSHADイメージ
				  +92 〜 +103 : EIP, CS, EFLAGS

				   +0 〜  +43は、shellcallルーチンのために用意する
							(読み込まれると取り去られる)
				  +44 〜 +103は、ハンドラが参照するために用意される */

				PUSH(GS);
				PUSH(FS);
				PUSH(DS);
				PUSH(ES);
				PUSHFD();
				ESP -= 40;
				EAX = (int) [SS:ESP +  64]; // EDI
				ECX = (int) [SS:ESP +  68]; // ESI
				EDX = (int) [SS:ESP +  72]; // EBP
				(int) [SS:ESP +  60] = EAX;
				(int) [SS:ESP +  64] = ECX;
				(int) [SS:ESP +  68] = EDX;
				EAX = (int) [SS:ESP +  80]; // EBX
				ECX = (int) [SS:ESP +  84]; // EDX
				EDX = (int) [SS:ESP +  88]; // ECX
				(int) [SS:ESP +  76] = EAX;
				(int) [SS:ESP +  80] = ECX;
				(int) [SS:ESP +  84] = EDX;
				EAX = (int) [SS:ESP +  92]; // EAX
				ECX = (int) [SS:ESP +  96]; // EIP
				EDX = (int) [SS:ESP + 100]; // CS
				(int) [SS:ESP +  88] = EAX;
				(int) [SS:ESP +  92] = ECX;
				(int) [SS:ESP +  96] = EDX;
				EAX = (int) [SS:ESP + 40]; // EFLAGS
				(int) [SS:ESP + 100] = EAX;
			} else {
				/* ハンドラからの帰還要求が出ている */

				/* スタックの上位(+44 〜 +103)は完成している
				   下位(+0 〜 +43)を作り直す */
				EAX = (int) [SS:ESP + 100]; // EFLAGS
				(int) [SS:ESP + 40] = EAX;
			}
			EAX = work->softint_EIP; /* ハンドラへのベクタ */
			ECX = work->softint_CS;
			(int) [SS:ESP + 32] = EAX;
			(int) [SS:ESP + 36] = ECX;
			(int) [SS:ESP + 12] = 2; /* リターン時のLlv */
			work->nest--; /* 割り込んだので、マスクカウントを減少 */
			PUSH(FS);
			LEA(EBX, work->softint_ret_buf[0]);
			work->softint_ret_buf[ 4] = 0;
			work->softint_ret_buf[ 8] = 0x0080; /* 割り込み抑制解除 */
			CALL(0x0017,0); /* GUIGUI統合shellcall */
			INT(0x03); /* エラーが無い限り、ここにはこない */
		}
	}

	/* ハンドラへの分岐はない */
	if ((unsigned) (int) [SS:ESP + 12] == 1) {
		/* 帰還 */
		ESP += 40; /* いらない部分を捨てる(EDI〜EAX, CS:EIP) */
		POP(ES);
		POP(DS);
		POP(EAX); /* FSへ直接ロードせずに、EAXに入れておく */
		POP(GS);
		(int) [SS:ESP + 12] = 2; /* リターン時のLlv */
		PUSH(EAX); /* ここで復帰後のFSを積む */
		LEA(EBX, work->softint_ret_buf[0]);
		work->softint_ret_buf[ 4] = 0;
		work->softint_ret_buf[ 8] = 0x0080; /* 割り込み抑制解除 */
		CALL(0x0017,0); /* GUIGUI統合shellcall */
		INT(0x03); /* エラーが無い限り、ここにはこない */
	}

	/* 何もないので、普通の正常終了 */
	LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更しない) */
	CALL(0x0017,0); /* shell-call */
//	(int) [SS:ESP + 16 /* EBX */] = (offset) cmd;
	CMP(EAX, EAX); /* ZF = 1, CF = 0 */
	POPAD();
	return;
}

void cmd0004_getbECX();
void cmd0004_getb(); /* CFに返す */
void cmd0004_decode();
void cmd0004_decode2();
void cmd0004_decode_tek1();
void cmd0004_decode_tek2();
void cmd0004_decode_tek5();

void far cmd004()
/* pioneer0ライブラリ初期化コマンド */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	/* work初期化(256bytes)
	   optionフィールドをもつ(malloc領域などのため)
	   malloc領域などの設定は、別のコマンドであとからやる。 */
	EAX = cmd[4] /* opt */;
	TEST(AL, 0x03);
	if (!= 0)
		goto special;
	XCHG(EAX, (offset) work);
	(offset) cmd += 8;
	(int) work->signature[0] = 0x6e6f6970 ; /* pion */
	(int) work->signature[4] = 0x30726565 ; /* eer0 */
	LEA(EAX, work->children_back);
	work->children_back = EAX;
	work->children_next = EAX;
	EAX = 0;
//	work->nest = 0xffffffff;
	work->read_ptr = EAX /* 0 */;
	work->softint_ret_buf[ 0] = 0x0208;
	work->softint_ret_buf[12] = EAX /* 0 */;
	work->signalbox_read_free = EAX /* 0 */;
	work->softint_mask_buf[ 0] = 0x0204;
	work->softint_mask_buf[ 4] = EAX /* 0 */;
	work->softint_mask_buf[ 8] = 0xff80;
	work->softint_mask_buf[12] = EAX /* 0x0000 */;
	work->signaldw = EAX /* 0 */;
	#if (defined (SAFEAPI_FLAG))
		work->signalbox_status = AL;
	#endif
//	work->signalbox_write_ptr = 0xfffffffe;
	work->ending_count = 0x80; /* bit7:生存フラグ, bit6-0:終了カウント */
	EAX--;
	work->nest = EAX /* 0xffffffff */;
	EAX--;
	work->signalbox_write_ptr = EAX /* 0xfffffffe */;
	/* ベクタ初期化 */
	PUSH(FS);
	PUSH(CS);
	POP(FS);
	asmout("MOV EBX,.cmd0004_cmd");
	CALL(0x0017,0); /* shell-call */
	POP(FS);
	/* slot 0x01f0に(offset) workを書き込み */
	PUSH((int) 0);
	PUSH((offset) work);
	ESP -= 8;
	PUSH((int) 0x01f0); /* slot-no. */
	PUSH((int) 0x0080); /* write user-slot */
	EBX = ESP;
	/* ユーザー割り込み抑制 */
	CALL(0x0017,0); /* shell-call */
	ESP += 24;
	asmout("JMP nextcmd");

special2:
	EAX = *cmd /* opt */;
	CMP(EAX, 0x0004);
	asmout("JE cmd004");
	TEST(AL, 0x03);
	if (== 0) {
		SAFE_CUT0("DB ..$-$-1,'special:SpecialEnd or Init command expected instead of ',0,'@',6,'.'");
	}
	(offset) cmd -= 4;

special:
	(offset) cmd += 4;
	if (EAX == 0xffffff81) {
		/* opt == 0xffffff81 : l2d3圧縮データー展開 */
		/* cmd, opt(subcmd), bytes, source(48bit), subcmd, ... */
		/* 展開先はES:EDI */
		POP(EDI);
		PUSH(DS);
		PUSH(ESI);
		PUSH(EBP);
		EBP = cmd[4];
		LDS(ESI, [DS:ESI + 8]);
		cmd0004_decode();
		POP(EBP);
		POP(ESI);
		POP(DS);
		PUSH(EDI);
		(offset) cmd += 16;
		goto special2;
	}
	if (EAX == 0xffffff82) {
		/* opt == 0xffffff82 : tek0圧縮データー展開 */
		/* cmd, opt(subcmd), bytes, source(48bit), subcmd, ... */
		/* 展開先はES:EDI */
		POP(EDI);
		PUSH(DS);
		PUSH(ESI);
		PUSH(EBP);
		EBP = cmd[4];
		LDS(ESI, [DS:ESI + 8]);
		cmd0004_decode2();
		POP(EBP);
		POP(ESI);
		POP(DS);
		PUSH(EDI);
		(offset) cmd += 16;
		goto special2;
	}
	if (EAX == 0xffffff83) {
		/* opt == 0xffffff83 : tek1圧縮データー展開 */
		/* cmd, opt(subcmd), bytes, source(48bit), subcmd, ... */
		/* 展開先はES:EDI */
		POP(EDI);
		PUSH(DS);
		PUSH(ESI);
		PUSH(EBP);
		EBP = cmd[4];
		LDS(ESI, [DS:ESI + 8]);
		cmd0004_decode_tek1();
		POP(EBP);
		POP(ESI);
		POP(DS);
		PUSH(EDI);
		(offset) cmd += 16;
		goto special2;
	}
	if (EAX == 0xffffff85) {
		/* opt == 0xffffff85 : tek2圧縮データー展開 */
		/* cmd, opt(subcmd), bytes, source(48bit), subcmd, ... */
		/* 展開先はES:EDI */
		POP(EDI);
		PUSH(DS);
		PUSH(ESI);
		PUSH(EBP);
		EBP = cmd[4];
		LDS(ESI, [DS:ESI + 8]);
		cmd0004_decode_tek2();
		POP(EBP);
		POP(ESI);
		POP(DS);
		PUSH(EDI);
		(offset) cmd += 16;
		goto special2;
	}
	if (EAX == 0xffffff89) {
		/* opt == 0xffffff89 : tek5圧縮データー展開 */
		/* subcmd, bytes, source(48bit), subcmd, ... */
		/* 展開先はES:EDI */
		PUSH(DS);
		PUSH(ESI);
		PUSH(EBP);
		EBP = cmd[4];
		LDS(ESI, cmd[8]);
		MOV(EAX, DS);
		EAX &= 0xfffc;
		if (EAX != 0x0004)
			INT(0x03); /* このAPIではコードセグメントのみ */
		LSL(EDX, AX);
		EDX++;
		cmd0004_decode_tek5();
		POP(EBP);
		POP(ESI);
		POP(DS);
		(offset) cmd += 16;
		goto special2;
	}
	if (EAX == 0xffffffff) {
		/* 特別終了 */
		POPAD();
		return;
	}
	SAFE_CUT0("DB ..$-$-1,'special:Invalid special command ',0,'.'");

	ALIGN(4);
cmd0004_cmd:
	asmout("DD 0200H, pioneer_softint, 010000C7H, 0201H"); /* softint_vector */
	asmout("DD 0204H, 0, 0281H"); /* to Llv2(nestを80に) */
	asmout("DD 0300H, 01C0H"); /* 獲得(この時、インターバルモードが解除される) */
asmout("cmd004_cmd2: equ $");
	asmout("DD 0310H, 01C0H"); /* 現在時刻設定 */
	asmout("DD 0318H, 01C0H, 0140H, 1, 0080H"); /* メッセージ設定 */
	DD(0x0000);
}

void cmd0004_getb()
{
	char *src == DS:ESI;

	BL--;
	if ((signed) < 0) {
		BL = 7;
		BH = *src;
		(offset) src++;
	}
	BH <<= 1;
	return;
}

void cmd0004_getbECX()
{
	char *src == DS:ESI;

	do {
		BL--;
		if ((signed) < 0) {
			BL = 7;
			BH = *src;
			(offset) src++;
		}
		BH <<= 1;
	//	RCL(EAX, 1);
		ADC(EAX, EAX);
		ECX--;
	} while (!= 0);
	TEST(EAX, EAX);
	return;
}

void cmd0004_decode()
/* これはもう主たるデコーダーではないので、多少遅くなってもいいからコンパクトに！ */
{
	char *dst == ES:EDI;

	EBX = 0;
	ECX = 0;
	for (;;) {
		EDX = (offset) &cmd0004_getbECX;
		EAX = 0;
		ECX++;
	//	cmd0004_getbECX(); /* 1bit入力 */
		CALL(EDX);
		if (!= 0) { /* EAX == 1 */
			CL = 8;
		//	cmd0004_getbECX(); /* 8bit入力 */
			CALL(EDX);
			ECX++;
			goto putc;
		}
		CL = 2;
	//	cmd0004_getbECX(); /* 2bit入力 */
		CALL(EDX);
	//	CL = 1;
		if (== 0) {
			CL = 4;
		//	cmd0004_getbECX(); /* 4bit入力 */
			CALL(EDX);
			CL = 4 - 1;
			if (== 0) {
				CL = 8;
			//	cmd0004_getbECX(); /* 8bit入力 */
				CALL(EDX);
				CL = 19 - 1;
				if (== 0) {
					CL = 16;
				//	cmd0004_getbECX(); /* 16bit入力 */
					CALL(EDX);
					if ((unsigned) EAX <= 127) {
						XCHG(EAX, ECX);
						EAX++; /* 最初のbitは1に決まっているから */
					//	cmd0004_getbECX(); /* nbit入力 */
						CALL(EDX);
					}
				}
			}
		}
		/* distanceはmaxで30bit(1GB) */
		EAX += ECX;
		PUSH(EAX);
		EAX = 0;
		EAX--;
		do {
			CL = 4;
		//	cmd0004_getbECX(); /* 4bit入力 */
			CALL(EDX);
			(signed int) EAX >>= 1;
		} while (CF == 1);
		POP(ECX);
		XCHG(EAX, EDX);
		do {
			AL = dst[EDX];
putc:
			*dst = AL;
			(offset) dst++;
			EBP--;
			if (== 0)
				goto fin;
			ECX--;
		} while (!= 0);
	}
fin:
	return;
}

void cmd0004_getl1a()
/* ECXに返す */
/* ECX = 1で呼ぶこと */
{
//	ECX = 1;
	cmd0004_getb();
	if (CF == 0) {
		do {
			cmd0004_getb();
		//	RCL(ECX, 1);
			ADC(ECX, ECX);
			cmd0004_getb();
		} while (CF == 0);
	}
	return;
}

void cmd0004_getl1b()
/* ECXに返す */
/* ECX = 1で呼ぶこと */
{
//	ECX = 1;
	cmd0004_getb();
	if (CF == 0) {
		do {
			cmd0004_getb();
		//	RCL(ECX, 1);
			ADC(ECX, ECX);
			cmd0004_getb();
		} while (CF == 0);
		ECX++;
		return;
	}
	cmd0004_getb();
	ADC(ECX, 0);
	return;
}

void cmd0004_getl0a()
/* EBPに返す */
/* 進入条件：EBP = 0, ECX = 0 */
{
	do {
		EBP++;
		cmd0004_getb();
		if (CF != 0)
			goto fin;
		EDX--;
	} while (!= 0);
	ECX++; /* ECX = 1; */
	cmd0004_getl1b();
	EBP += ECX;
	ECX = 0;	
fin:
	return;
}

void cmd0004_decode2()
{
	char *dst == ES:EDI;
	unsigned int *z1 == SS:ESP, *z0 == SS:ESP + 4, *mode == SS:ESP + 8;
	unsigned int *l_ofs == SS:ESP + 12, *dis_s == SS:ESP + 16;
	unsigned int *bytes == SS:ESP + 20;
	EBX = 0;
	ECX = 0;
	EAX = 0;
	PUSH(EBP); /* bytes */
	do {
		CL = 9;
		cmd0004_getbECX(); /* 9bit入力 */
		(unsigned int) EAX >>= 1;
	} while (CF == 0);
	PUSH(EAX); /* dis_s */
	EAX = 0;
	CL = 2;
	cmd0004_getbECX(); /* 2bit入力 */
	PUSH(EAX); /* l_ofs */
	EAX = (offset) &cmd0004_getl1a;
	cmd0004_getb();
	if (CF != 0) {
	//	EAX = (offset) &cmd0004_getl1b;
		asmout("ADD EAX,cmd0004_getl1b-cmd0004_getl1a");
	//	DB(0x83, 0xc0); asmout("DB cmd0004_getl1b-cmd0004_getl1a");
	}
	PUSH(EAX); /* mode */
	LEA(EDX, [ECX + 2]); /* EDX = 2; */
	do {
		EAX = 0;
		CL = 2;
		cmd0004_getbECX(); /* 2bit入力 */
		asmout("MOVSX EAX,BYTE PTR CS:[#table+EAX]");
		PUSH(EAX); /* z0, z1 */
		EDX--;
	} while (!= 0);

	EBP = 0;
	do {
		/* "0"-phase (非圧縮フェーズ) */
		EDX = *z0;
		cmd0004_getl0a(); /* EBPに返す */
		*bytes -= EBP;
		do {
			CL = 8;
			cmd0004_getbECX();
			*dst = AL;
			(offset) dst++;
			EBP--;
		} while (!= 0);
		if (ECX == *bytes)
			break;

		/* "1"-phase (圧縮フェーズ) */
		EDX = *z1;
		cmd0004_getl0a(); /* EBPに返す */
		do {
			/* getdf */
			unsigned int stopbits == EAX, distance == EDX;
		//	distance = 0xffffffff;
			LEA(EDX, [ECX - 1]);
			ECX++; /* l1aやl1bのため */
			stopbits = *dis_s;
			do {
				do {
					cmd0004_getb();
				//	RCL(distance, 1);
					ADC(distance, distance);
					stopbits >>= 1;
				} while (CF == 0);
				if (/* stopbits */ == 0)
					break;
				cmd0004_getb();
			} while (CF == 0);

			CALL(*mode); /* l1a or l1b */
			ECX += *l_ofs;
			*bytes -= ECX;
			do {
				AL = dst[EDX];
				*dst = AL;
				(offset) dst++;
				ECX--;
			} while (!= 0);
			EBP--;
		} while (!= 0);
	} while (ECX != *bytes);

	ESP += 24;
	return;

table:
	DB(0xff, 4, 8, 16);
}

void getnum_s7s()
/* DS:ESIからリード */
{
	EAX = 0;
	do {
		EAX <<= 8;
		LODSB();
		(unsigned int) EAX >>= 1;
	} while (CF == 0);
	return; /* CF = 1, TEST(EAX, EAX); */
}

void cmd0004_decode_tek1()
{
	PUSHFD();
	CLD();
	getnum_s7s();
	TEST(AL, 0x40);
	if (!= 0)
		getnum_s7s(); /* オプション情報へのポインタを読み飛ばす */
	LODSB();
	if (AL != 0x01)
		INT(0x03); /* 補助バッファ検出 */
	if (EBP == 0)
		goto fin;

	EBP += EDI;
	ECX = 0;
	PUSH(EDI);
	do {
		CL = (unsigned char) [DS:ESI];
		ESI++;
		EBX = ECX; /* by */
		ECX &= 0x0f;
		if (== 0)
			goto getlong_by;
getlong_by0:
		(unsigned int) EBX >>= 4;
		if (== 0)
			goto getlong_lz;
getlong_lz0:
		asmout("REP MOVSB");
		if ((unsigned) EDI >= EBP)
			break;
		do {
			EDX = (unsigned char) [DS:ESI];
			ESI++;
			ECX = EDX;
			EDX &= 0x0f;
			(unsigned int) EDX >>= 1;
			if (CF == 0) {
				do {
					EDX <<= 8;
					DL = [DS:ESI];
					ESI++;
					(unsigned int) EDX >>= 1;
				} while (CF == 0);
			}
			ECX >>= 4;
			if (== 0)
				goto long_cp;
long_cp0:
			ECX++;
			NOT(EDX);
			PUSH(ESI);
			LEA(EAX, [EDI + ECX]);
			LEA(ESI, [EDI + EDX]);
			if ((unsigned) EAX > EBP)
				goto fix_ECX;
fix_ECX1:
			if ((unsigned) ESI < [SS:ESP + 4])
				goto err;
			asmout("REP ES MOVSB");
			POP(ESI);
			EBX--;
		} while (!= 0);
	} while ((unsigned) EDI < EBP);
	POP(EAX);
fin:
	POPFD();
	return;

getlong_lz:
	getnum_s7s();
	XCHG(EAX, EBX);
	goto getlong_lz0;

getlong_by:
	getnum_s7s();
	XCHG(EAX, ECX);
	goto getlong_by0;

long_cp:
	getnum_s7s();
	XCHG(EAX, ECX);
	goto long_cp0;

fix_ECX:
	ECX = EBP;
	ECX -= EDI;
	goto fix_ECX1;

err:
	INT(0x03);
}

void getnum_s7()
/* DS:ESIからリード */
/* ECX, EDX 破壊 */
{
	int tmp0 == ECX, tmp1 == EDX;
	EAX = 0;
	LODSB();
	(unsigned int) EAX >>= 1;
	if (CF == 0) {
		tmp1 = 0;
		tmp0 = 0;
		tmp1++;
		do {
			tmp1 <<= 7;
			EAX <<= 8;
			tmp0 += tmp1;
			LODSB();
			(unsigned int) EAX >>= 1;
		} while (CF == 0);
		EAX += tmp0; /* CF = 0, TEST(EAX, EAX); */
	}
	return;
}

void cmd0004_decode_tek2()
{
	PUSHFD();
	CLD();
	getnum_s7s();
	TEST(AL, 0x40);
	if (!= 0)
		getnum_s7s(); /* オプション情報へのポインタを読み飛ばす */
	LODSB();
	if (AL != 0x01)
		INT(0x03); /* 補助バッファ検出 */
	if (EBP == 0)
		goto fin;

	EBP += EDI;
	DH = 0;
	PUSH(EDI);
	PUSH(EBP);
	PUSH(3);
	PUSH(2);
	PUSH(1);
	PUSH(0);
	EBP = ESP;
	do {
		/* byの長さの取得 */
		/* これは長くなりやすい */
		ECX = 0;
		do {
			ECX++;
			if ((unsigned) ECX >= 17)
				goto long_by0;
			if (DH == 0) {
				DH = 8;
				DL = [DS:ESI];
				ESI++;
			}
			DH--;
			(unsigned char) DL >>= 1;
		} while (CF == 0);
long_by1:
		asmout("REP MOVSB");
		if ((unsigned) EDI >= [SS:EBP + 16])
			break;

		/* lzの長さの取得 */
		ECX = 0;
		do {
			ECX++;
			if ((unsigned) ECX >= 17)
				goto long_lz0;
			if (DH == 0) {
				DH = 8;
				DL = [DS:ESI];
				ESI++;
			}
			DH--;
			(unsigned char) DL >>= 1;
		} while (CF == 0);
long_lz1:
		EBX = ECX;
		PUSH(EDX);
		do {
			EDX = (unsigned char) [DS:ESI];
			ESI++;
			PUSH(EDX);
			EDX &= 0x0f;
			(unsigned int) EDX >>= 1;
			if (CF == 0) {
				EAX = (unsigned char) [DS:ESI];
				ESI++;
				(unsigned int) EAX >>= 1;
				if (CF == 0)
					goto long_ds0;
	long_ds1:
				LEA(EDX, [EDX + EAX * 8 + 8]);
			}
			PUSH(EDI);
			ECX = [SS:EBP +  8];
			EAX = [SS:EBP +  4];
			EDI = [SS:EBP +  0];
			EDX -= 6;
			if ((unsigned) < 0)
				goto repdis_hit;
	repdis_hit3:
			[SS:EBP + 12] = ECX;
	repdis_hit2:
			[SS:EBP +  8] = EAX;
	repdis_hit1:
			[SS:EBP +  4] = EDI;
	repdis_hit0:
			POP(EDI);
			[SS:EBP +  0] = EDX;
			POP(ECX);
			NOT(EDX);
			(unsigned int) ECX >>= 4;
			if (== 0)
				goto long_cp0;
			ECX++;
	long_cp1:
			PUSH(ESI);
			LEA(EAX, [EDI + ECX]);
			LEA(ESI, [EDI + EDX]);
			if ((unsigned) EAX > [SS:EBP + 16])
				goto fix_ECX;
fix_ECX1:
			if ((unsigned) ESI < [SS:EBP + 20])
				goto err;
			asmout("REP ES MOVSB");
			POP(ESI);
			EBX--;
		} while (!= 0);
		POP(EDX);
	} while ((unsigned) EDI < [SS:EBP + 16]);
	ESP += 24;
fin:
	POPFD();
	return;

long_by0:
	getnum_s7s();
	ECX += EAX;
	goto long_by1;

long_lz0:
	getnum_s7s();
	ECX += EAX;
	goto long_lz1;

long_ds0:
	PUSH(EDX);
	ESI--;
	getnum_s7();
	POP(EDX);
	goto long_ds1;

long_cp0:
	ECX = (unsigned char) [DS:ESI];
	ESI++;
	ECX += 17 * 2;
	(unsigned int) ECX >>= 1;
	if (CF != 0)
		goto long_cp1;
	PUSH(EDX);
	ESI--;
	getnum_s7();
	POP(EDX);
	LEA(ECX, [EAX + 17]);
	goto long_cp1;

repdis_hit:
	if (DL == -6)
		goto repdis0_hit;
	if (DL == -5)
		goto repdis1_hit;
	if (DL == -4)
		goto repdis2_hit;
	if (DL == -2)
		goto rel0;
	if (DL == -1)
		goto rel1;
	EDX = [SS:EBP + 12];
	goto repdis_hit3;
repdis0_hit:
	EDX = [SS:EBP + 0];
	goto repdis_hit0;
repdis1_hit:
	EDX = [SS:EBP + 4];
	goto repdis_hit1;
repdis2_hit:
	EDX = [SS:EBP + 8];
	goto repdis_hit2;

rel0:
	[SS:EBP + 12] = ECX;
	[SS:EBP +  8] = EAX;
	getnum_s7();
	LEA(EDX, [EDI + EAX + 1]);
	goto repdis_hit1;

rel1:
	[SS:EBP + 12] = ECX;
	[SS:EBP +  8] = EAX;
	getnum_s7();
	NEG(EAX);
	LEA(EDX, [EDI + EAX - 1]);
	goto repdis_hit1;

fix_ECX:
	ECX = [SS:EBP + 16];
	ECX -= EDI;
	goto fix_ECX1;

err:
	INT(0x03);
}

void decodemain();
void decodemain1();

struct STR_BITMODEL { /* 32バイト */
	unsigned char t, m, s, dmy;
	unsigned int prb0, prb1, tmsk, ntm, lt, lt0, prb01;
};

struct STR_TEK5 { /* 320x4 */
	int p;
	unsigned int range, code, lit1, repdis[16];
	STR_BITMODEL bm[1024]; /* 32 * 32 */
	int ptbm[64]; /* 16 * 4 */
	int nowPos, state, posStateMask;
	unsigned char lc8, lc, lit0cntmsk, dmy_uc;
	int literalPosMask, outSize, outStream, q0, dmy2[128];
};

struct STR_LZMA {
	int repdis[16], nowPos, state, posStateMask;
	unsigned char lc8, lc, previousIsMatch, previousByte;
	int literalPosMask, outSize, outStream;
	int rd_src, rd_src1, rd_range, rd_code;
	int p[1234];
};

void setbm();

/* ASKAのバグ回避用 */
#define aBM		bm[EDI]

void lzrestore_tek5()
/* ESI, EDI, EBP */
{
	LODSB();
	AH = AL;
	AL &= 0x0f;
	if (AL == 0x01)
		goto tek5_z0;
	if (AL == 0x05)
		goto tek5_z1;
	if (AL == 0x09)
		goto tek5_z2;
err:
	EAX = 0;
	EAX++;
	return;
tek5_z0:
	(unsigned char) EAX >>= 12;
	CL = 9 * 5;
	EAX &= 0x0f;
	if (!= 0) {
		if ((unsigned) AL >= 3)
			goto err;
		asmout("MOV AL,[CS:.prm_table-1+EAX]");
	} else
		LODSB();
	DIV(CL);
	ROR(EAX, 8); /* pbを24-31へ, AHをALへ */
	CL = 9;
	AH = 0;
	DIV(CL);
	CL = AL; /* lp */
	CL += AH; /* lc */
	EBX = 768; /* LZMA_LIT_SIZE */
	SHL(EBX, CL);
	EBX += 1846; /* LZMA_BASE_SIZE */

	ECX = ESP;
	do {
		PUSH(1024);
		EBX--;
	} while (!= 0);
	PUSH(EAX); /* rd->Code */
	PUSH(-1); /* rd->Range */
	PUSH(EDI); /* rd->BufferLim -> outstream0 */
	PUSH(ESI);
	PUSH(EDI);
	PUSH(EBP); /* 出力サイズ */
	EDI = ECX;

	CL = AL; /* lp */
	EBX = 256;
	CL += AH; /* lc */
	SHL(EBX, CL);
	EBX += 1846 /* Literal */;

	EDX = 0;
	EDX++;
	CL = AL; /* lp */
	SHL(EDX, CL);
	EDX--;
	PUSH(EDX); /* literalPosMask */
	AL = 8;
	AL -= AH;
	/* AH:lc, AL:8-lc */
	PUSH(EAX); /* 8-lc, lc, 0, pb */
	ROL(EAX, 8);
	EDX = 0;
	EDX++;
	CL = AL; /* pb */
	SHL(EDX, CL);
	EDX--;
	PUSH(EDX); /* posStateMask */
	PUSH(0); /* state */
	PUSH(1); /* nowPos */
	PUSH(-4); /* rep0-3 */
	PUSH(-3);
	PUSH(-2);
	PUSH(-1);

	EBP = ESP;
	PUSH(EDI); /* 旧スタック */
	/* 合計で64KBくらいの余裕がほしい */

	CL = 4;
	do {
		EAX <<= 8;
		LODSB();
		CL--;
	} while (!= 0);
	STR_LZMA *work0 == SS:EBP;
	work0->rd_src = ESI;
	work0->rd_code = EAX;
	work0->p[1846 * 4] = EBX;

	decodemain();

	POP(EAX);
	XCHG(EAX, ESP);
	EAX = 0;
	return;

prm_table:
	DB(0x5d, 0x00);

tek5_z1:
tek5_z2:
	BL = AL;
	(unsigned char) EAX >>= 12;
	CL = 9 * 5;
	EAX &= 0x0f;
	if (!= 0) {
		if ((unsigned) AL >= 2)
			goto err;
		asmout("MOV AL,[CS:.prm_table1-1+EAX]");
	} else
		LODSB();
	DIV(CL);
	/* AL = lp; AH = lc + pb * 9; */
	BH = AL; /* lp */
	AL = AH;
	CL = 9;
	AH = 0;
	DIV(CL);
	/* AL = pb, AH = lc, BH = lp */
	CL = BH;
	CL += AH;
	EDX = 768;
	SHL(EDX, CL);
	EDX += 2064;
	ECX = ESP;
	do {
		PUSH(0x8000);
		EDX--;
	} while (!= 0);
	ESP -= 128;
	EDX++; /* EDX = 1 */
	PUSH(EDI); /* q0 */
	PUSH(EDI); /* q */
	EDI = ECX; /* old ESP */
	PUSH(EBP); /* siz */
	CL = BH; /* lp */
	SHL(EDX, CL);
	EDX--;
	PUSH(EDX); /* literalPosMask */
	EDX = 0x00780008;
	DH = AH;
	DL -= AH;
	PUSH(EDX); /* とりあえず lit0cntmsk=0x78 */
	EDX |= -1;
	CL = AL; /* pb */
	SHL(EDX, CL);
	NOT(EDX);
	PUSH(EDX); /* posStateMask */
	PUSH(0); /* state */
	PUSH(1); /* nowPos */
	DL = 16;
	do {
		PUSH(8); /* ptbm */
		DL--;
	} while (!= 0);
	ESP -= 1024;
	PUSH(-4); /* rep0-3 */
	PUSH(-3);
	PUSH(-2);
	PUSH(-1);
	EDX = 256;
	CL = AH;
	CL += BH;
	SHL(EDX, CL);
	EDX += 320 + 2064;
	PUSH(EDX); /* lit1 */
	/* 以降EAX破壊 */
	BH = -1;
	if (BL == 0x09) {
		LODSB();
		BH = AL;
	}
	CL = 4;
	do {
		EAX <<= 8;
		LODSB();
		CL--;
	} while (!= 0);
	PUSH(EAX); /* code(仮) */
	PUSH(-1); /* range */
	PUSH(ESI);
	EBP = ESP;
	PUSH(EDI); /* 旧スタック */

	STR_TEK5 *work == SS:EBP;
//	STR_BITMODEL *bm == SS:EBP + EDI;
	STR_BITMODEL *bm == SS:EBP;
	EDI = 32;
	do {
		aBM.lt  = 1;
		aBM.lt0 = 16 * 1024;
		if ((unsigned) EDI < 160) { /* 32 + 4 * 32 */
			aBM.lt  = 0x7fffffff;
			aBM.lt0 = 0x80000000;
		}
		if ((unsigned) EDI >= 800) /* 32 + 24 * 32 */
			aBM.lt0 = 8 * 1024;
		aBM.t = 5;
		aBM.m = 5;
		aBM.s = 0;
		EDI += 32;
	} while ((unsigned) EDI < 1056); /* 32 + 32 * 32 */
//	bm[64].t = 5; /* bm[1], for fchgprm */
	bm[64].m = 3;
	bm[96].t = 9; /* bm[2], for tbmt, tbmm */
	bm[96].m = 2;
	TEST(BH, 0x40);
	if (!= 0) {
		bm[128].t = 0; /* bm[3], for fchglt */
		bm[128].m = 1;
		(int) [SS:EBP + 1536] = 0xffff; /* (320 + 64) * 4 == fchglt */
	}
	bm[736].t = 0; /* bm[22], for repg3 */
	bm[736].m = 1;
	(int) [SS:EBP + 1540] = 0xffff; /* (320 + 65) * 4 == repg3 */
	AL = 18;
	(char) [SS:EBP + 1096] = AL; /* 32 + 1024 + 4 * 10 == ptbm[10] */
	(char) [SS:EBP + 1100] = AL; /* 32 + 1024 + 4 * 11 == ptbm[11] */
	(char) [SS:EBP + 1104] = AL; /* 32 + 1024 + 4 * 12 == ptbm[12] */
	if (BL == 0x05) {
		/* z1 */
		bm[736].lt  = 0x7fffffff; /* bm[22], for repg3 */
		bm[736].lt0 = 0x80000000;
	} else {
		EDI = 32 + 1024;
		AL = 8;
		do {
			(char) [SS:EBP + EDI] = AL;
			EDI += 4;
			EAX++;
		} while ((unsigned) AL < 22);
		CL = BH;
		AL = 0x7f;
		CL &= 0x03;
		SHR(AL, CL);
		AL &= 0x78;
		work->lit0cntmsk = AL;
		TEST(BH, 0x04);
		if (== 0)
			(char) [SS:EBP + 1060]--; /* 32 + 1024 +  1 * 4 == ptbm[ 1] */
		TEST(BH, 0x08);
		if (== 0)
			(char) [SS:EBP + 1076]--; /* 32 + 1024 +  5 * 4 == ptbm[ 5] */
		TEST(BH, 0x10);
		if (== 0)
			(char) [SS:EBP + 1092]--; /* 32 + 1024 +  9 * 4 == ptbm[ 9] */
		TEST(BH, 0x20);
		if (== 0)
			(char) [SS:EBP + 1100]--; /* 32 + 1024 + 11 * 4 == ptbm[11] */
	}
	EDI = 32 + 1024;
	do {
		EAX = [SS:EBP + EDI];
		EAX++;
		EAX *= 32;
		[SS:EBP + EDI] = EAX;
		EDI += 4;
	} while ((unsigned) EDI < 1120); /* 32 + 1024 + 16 * 4 */
	EDI = 32;
	do {
		setbm();
		EDI += 32;
	} while ((unsigned) EDI < 1056); /* 32 + 32 * 32 */

	decodemain1();

	POP(EAX);
	XCHG(EAX, ESP);
	EAX = 0;
	return;

prm_table1:
	DB(0x00);
}

/* 以下z0専用 */

#define kTopValue				0x01000000
#define kNumBitModelTotalBits 	11
#define kBitModelTotal			0x0800
#define kNumMoveBits			5

void rdd_direct();
void rdd_bit();
void rdd_bittree();
void rdd_literal();
void getlen();

void rdd_direct()
/* EBP, ECX, ESI */
{
	STR_LZMA *work == SS:EBP;
	unsigned int result == EDX, range == EDI, code == EAX;
	unsigned char *src == DS:ESI;
	do {
		if ((unsigned) range < kTopValue)
			goto shift;
shift1:
		range >>= 1;
		CMP(code, range); /* >= なら CF = 0 */
		if ((unsigned) >=)
			code -= range; /* 相変わらずCF = 0 */
		RCL(result, 1);
		ECX--;
	} while (!= 0);
	return;
shift:
	code <<= 8;
	range <<= 8;
	LODSB();
	goto shift1;	/* 1回でかならず足りるかどうかはそれより前による */
}

/* 00000011111 */
/* 11111100001 */
/* どちらにしても、1回で足りる */

void rdd_bittree()
{
	EDX = 1;
}

void rdd_bittree0()
/* 結果は上位ビットにごみがつくので、呼び出し元でマスクせよ */
/* EBX:prob0 */
{
	STR_LZMA *work == SS:EBP;
	unsigned int result == EDX, range == EDI, code == EAX;
	unsigned int bound == EBX, prob == EDX, tmp == ECX;
	unsigned char *src == DS:ESI;

	do {
		PUSH(EBX);
		EBX += result;
		PUSH(result);
		PUSH(ECX);
		PUSH(EBX);
		prob = work->p[EBX * 4];
		if ((unsigned) range < kTopValue)
			goto shift;
shift1:
		bound = range;
		tmp = prob;
		bound >>= kNumBitModelTotalBits;
		IMUL(bound, prob);
		if ((unsigned) code < bound) {
			range = bound;
			prob--;
			bound = 0;
			tmp -= kBitModelTotal + 1;
		}
		code -= bound;
		range -= bound;
		(signed int) tmp >>= kNumMoveBits;
		POP(EBX);
		prob -= tmp; /* CFにデコード結果 */
		POP(ECX);
		work->p[EBX * 4] = prob;
		POP(result);
		POP(EBX);
		RCL(result, 1);
		CL--;
	} while (!= 0);
	return;
shift:
	code <<= 8;
	range <<= 8;
	LODSB();
	goto shift1;
}

#define LenChoice			0
#define LenChoice2			1
#define LenLow				2
#define LenMid				130
#define LenHigh				258
#define kLenNumLowBits		3
#define kLenNumMidBits		3
#define kLenNumHighBits		8

void getlen()
/* EBXにprob0, EDX:posState */
/* EDXに返す */
{
	PUSH(EDX);
	rdd_bit(); /* LenChoice */
	if (CF == 0) {
		POP(EDX);
		CL = kLenNumLowBits;
		LEA(EBX, [EBX + EDX * 8 + 2]); /* EBX += LenLow + posState << kLenNumLowBits */
		rdd_bittree();
		EDX -= 8;
		return;
	}
	EBX++;
	rdd_bit(); /* LenChoice2 */
	POP(EDX);
	if (CF == 0) {
		CL = kLenNumMidBits;
		LEA(EBX, [EBX + EDX * 8 + 129]); /* EBX += LenMid - 1 + posState << kLenNumMidBits */
	//	rdd_bittree();
	//	EDX += 8 - 8;
	//	return;
		goto rdd_bittree;
	}
	EBX += LenHigh - 1;
	CL = kLenNumHighBits;
	rdd_bittree();
	EDX -= 248 + 256; /* kLenNumHighSymbols - 8 */
	if ((unsigned) > 0) {
		ECX = EDX;
		EDX = 1;
		rdd_direct();
		LEA(ECX, [EDX - 1]);
		EDX = 1;
		rdd_direct();
		EDX--;
	}
	EDX += 16 + 248;
	return;
}

#define kNumPosSlotBits 		6
#define kNumLenToPosStates1 	3
#define kNumPosBitsMax 			4
#define kStartPosModelIndex 	4
#define kEndPosModelIndex		14
#define kNumAlignBits			4
#define kMatchMinLen			2

#define IsMatch			0
#define IsRep			192
#define IsRepG0			204
#define IsRepG1			216
#define IsRepG2			228
#define IsRep0Long		240
#define PosSlot			432
#define SpecPos			688
#define Align			802
#define LenCoder		818
#define RepLenCoder		1332
#define Literal			1846

void rdd_bit()
/* prob:EBX > CF */
{
	STR_LZMA *work == SS:EBP;
	unsigned int range == EDI, code == EAX;
	unsigned int bound == EBX, prob == EDX, tmp == ECX;
	unsigned char *src == DS:ESI;

	PUSH(EBX);
	prob = work->p[EBX * 4];
	if ((unsigned) range < kTopValue)
		goto shift;
shift1:
	bound = range;
	tmp = prob;
	bound >>= kNumBitModelTotalBits;
	IMUL(bound, prob);
	if ((unsigned) code >= bound) {
		code -= bound;
		range -= bound;
		(signed int) tmp >>= kNumMoveBits;
		POP(EBX);
		prob -= tmp; /* CF = 0 */
		work->p[EBX * 4] = prob;
		return;
	}
	prob--;
//	tmp += - kBitModelTotal + 32 - 1;
	tmp -= kBitModelTotal + 1;
	range = bound;
	(signed int) tmp >>= kNumMoveBits;
	POP(EBX);
	prob -= tmp; /* CF = 1 */
	work->p[EBX * 4] = prob;
	return;
shift:
//	do {
		code <<= 8;
		range <<= 8;
		LODSB();
//	} while ((unsigned) range < kTopValue);
	goto shift1;
}

#define SEG_ES	ES
#define SEG_CS	CS

void decodemain()
/* EBP */
{
	STR_LZMA *work == SS:EBP;
	ESI = work->rd_src;
//	EDI = work->rd_range;
	EDI |= -1;
	EAX = work->rd_code;
	EBX = IsMatch;
	rdd_bit(); /* これはかならずCF = 0になる（stk5では） */
	if (CF != 0)
		goto err;
	EBX = Literal;
	CL = 8;
	rdd_bittree();
	EBX = work->outStream;
	[SEG_ES:EBX] = DL;
	EBX++;
	work->outStream = EBX;
	EDX = work->nowPos;
	if ((unsigned) EDX < work->outSize) {
loophead:
		EBX = work->state;
		EDX &= work->posStateMask;
		EBX <<= kNumPosBitsMax;
		PUSH(EDX); /* posState */
		EBX += EDX;
		rdd_bit();
		if (CF == 0) {	/* not LZ */
			POP(EDX);
			EBX = work->state;
			PUSH(EDI);
			EDX = work->nowPos;
			EDI = work->outStream;
		//	BL = [SEG_CS:state_table + EBX];
			asmout("MOV BL,[CS:.state_table+EBX]");
			EDX &= work->literalPosMask;
			(char) work->state = BL;
			CL = work->lc;
			EBX = (unsigned char) [SEG_ES:EDI - 1];
			SHL(EDX, CL);
			CL = work->lc8;
			SHR(EBX, CL);
			EBX += EDX;
		//	EDX = work->repdis[0];
			EBX *= 256;
			POP(EDI);
			EBX += Literal;
			CL = 8;
			rdd_bittree();
//lit11:
			EBX = work->outStream;
			[SEG_ES:EBX] = DL;
			EDX = work->nowPos;
			EBX++;
			EDX++;
			work->outStream = EBX;
			work->nowPos = EDX;
			if ((unsigned) EDX < work->outSize)
				goto loophead;
			goto fin;
		}
lzphase:
		/* LZ */
		EBX = work->state;
		EBX += IsRep;
		rdd_bit();
		if (CF != 0) {	/* repdis */
			EBX += IsRepG0 - IsRep;
			rdd_bit();
			if (CF == 0) {	/* rep[0] */
				EBX = work->state;
				POP(EDX);
				EBX <<= kNumPosBitsMax;
				PUSH(EDX);
				LEA(EBX, [EBX + EDX + IsRep0Long]);
				rdd_bit();
				if (CF == 0) { /* rep[0] && len == 1 */
					POP(EDX);
					BL = (char) work->state;
					PUSH(EDI);
					CMP(BL, 7);
					EDI = work->outStream;
					EDX = work->repdis[0];
					SBB(BL, BL); /* -1, 0 */
					PUSH(EAX);
					BL &= -2;
					AL = [SEG_ES:EDI + EDX];
					EDX = work->nowPos;
					BL += 11; /* 9, 11 */
					STOSB();
					(char) work->state = BL;
					EDX++;
					work->outStream = EDI;
					POP(EAX);
					work->nowPos = EDX;
					POP(EDI);
					if ((unsigned) EDX < work->outSize)
						goto lzdone;
					goto fin;
				}
			} else {
				EBX += IsRepG1 - IsRepG0;
				rdd_bit();
				EDX = work->repdis[4];
				if (CF != 0) {	/* not rep[1] */
					EBX += IsRepG2 - IsRepG1;
					rdd_bit();
					EDX = work->repdis[8];
					if (CF != 0) {	/* not rep[2] */
						EBX = EDX;
						EDX = work->repdis[12];
						work->repdis[12] = EBX;
					}
					EBX = work->repdis[4];
					work->repdis[8] = EBX;
				}
				EBX = work->repdis[0];
				work->repdis[0] = EDX;
				work->repdis[4] = EBX;
			}
			BL = (char) work->state;
			POP(EDX);
			CMP(BL, 7);
			SBB(BL, BL); /* -1, 0 */
			BL &= -3;
			BL += 11; /* 8, 11 */
			(char) work->state = BL;
			EBX = RepLenCoder;
			getlen();
			ECX = EDX;
			EDX = work->repdis[0];
		} else {
			/* not repdis */
			EDX = work->repdis[8];
			EBX = work->repdis[4];
			work->repdis[12] = EDX;
			EDX = work->repdis[0];
			work->repdis[8] = EBX;
			work->repdis[4] = EDX;
			BL = (char) work->state;
			POP(EDX); /* posState */
			CMP(BL, 7);
			SBB(BL, BL); /* -1, 0 */
			BL &= -3;
			BL += 10; /* 7, 10 */
			(char) work->state = BL;
			EBX = LenCoder;
			getlen();
			EBX = EDX;
			PUSH(EDX); /* len */
			if ((unsigned) EBX >= kNumLenToPosStates1)
				EBX = kNumLenToPosStates1;
			EBX <<= kNumPosSlotBits;
			CL = kNumPosSlotBits;
			EBX += PosSlot;
			rdd_bittree();
			EDX &= 0x3f;
			if ((unsigned) EDX >= kStartPosModelIndex) {
				ECX = EDX;
				EBX = EDX;
				(unsigned int) ECX >>= 1;
				EDX = 1;
				ECX--; /* CF不変 */
				RCL(EDX, 1);
				if ((unsigned) EBX < kEndPosModelIndex) {
					/* リバースでECXビットをEDXに押し込む */
					PUSH(EDX);
					SHL(EDX, CL);
					NOT(EBX);
					PUSH(ECX);
					LEA(EBX, [EBX + EDX + SpecPos]);
					rdd_bittree();
					EBX = EDX;
					POP(ECX);
				} else {
					ECX -= kNumAlignBits;
					rdd_direct();
					CL = kNumAlignBits;
					EBX = Align;
					PUSH(EDX);
					rdd_bittree();
					EBX = EDX;
					CL = kNumAlignBits;
				}
				POP(EDX);
				do {
					(unsigned int) EBX >>= 1;
					RCL(EDX, 1);
					ECX--;
				} while (!= 0);
			}
			NOT(EDX);
			POP(ECX); /* len */
			work->repdis[0] = EDX;
		}
	//	if (EDX == 0)
	//		break;
		PUSH(EDI);
		ECX += kMatchMinLen;
		PUSH(ESI);
		EDI = work->outStream;
		ESI = work->outSize;
		ESI -= work->nowPos;
		if ((unsigned) ECX >= ESI)
			ECX = ESI;
		LEA(ESI, [EDI + EDX]);
		work->nowPos += ECX;
		if ((unsigned) ESI < work->rd_src1)
			goto err;
		asmout("REP ES MOVSB");
		work->outStream = EDI;
		POP(ESI);
		EDX = work->nowPos;
		POP(EDI);
		if ((unsigned) EDX >= work->outSize)
			goto fin;
lzdone:
		EBX = work->state;
		EDX &= work->posStateMask;
		EBX <<= kNumPosBitsMax;
		PUSH(EDX); /* posState */
		EBX += EDX;
		rdd_bit();
		if (CF != 0)
			goto lzphase;
		POP(EDX);
		EBX = work->state;
		PUSH(EDI);
	//	BL = [SEG_CS:state_table + EBX];
		asmout("MOV BL,[CS:.state_table+EBX]");
		EDX = work->nowPos;
		(char) work->state = BL;
		EDI = work->outStream;
		EDX &= work->literalPosMask;
		CL = work->lc;
		EBX = (unsigned char) [SEG_ES:EDI - 1];
		SHL(EDX, CL);
		CL = work->lc8;
		SHR(EBX, CL);
		EBX += EDX;
		EDX = work->repdis[0];
		EBX *= 256;
		CL = [SEG_ES:EDI + EDX];
		POP(EDI);
lit1:
		unsigned int result == EDX, range == EDI, code == EAX;
		unsigned int bound == EBX, prob == EDX, tmp == ECX;
		PUSH(EBX);
		MOV(result, 1);
		EBX *= 2;
		EBX += work->p[Literal * 4];
		do {
			ECX *= 2;
			PUSH(EBX);
			EBX += result;
			PUSH(result);
			PUSH(ECX);
			ECX &= 0x100;
			EBX += ECX;
			PUSH(EBX);
			prob = work->p[EBX * 4];
			if ((unsigned) range < kTopValue)
				goto lit1load0;
lit1load1:
			bound = range;
			tmp = prob;
			bound >>= kNumBitModelTotalBits;
			IMUL(bound, prob);
			if ((unsigned) code < bound) {
				range = bound;
				prob--;
				bound = 0;
				tmp -= kBitModelTotal + 1;
			}
			code -= bound;
			range -= bound;
			(signed int) tmp >>= kNumMoveBits;
			POP(EBX);
			prob -= tmp; /* CFにデコード結果 */
			POP(ECX);
			work->p[EBX * 4] = prob;
			POP(result);
			POP(EBX);
			RCL(result, 1);
			if ((unsigned) result >= 0x100)
				goto finlit1;
			DH = DL;
			DH ^= CH;
			TEST(DH, 1);
			MOV(DH, 0);
		} while (== 0);
		EBX = result;
		CL = 0;
		do {
			EBX *= 2;
			CL++;
		} while ((unsigned) EBX < 0x100);
		POP(EBX);
		EBX += Literal;
		rdd_bittree0();
		goto lit11;
	}
lit1load0:
	code <<= 8;
	range <<= 8;
	LODSB();
	goto lit1load1;
finlit1:
	POP(EBX);
	goto lit11;
lit11:
	EBX = work->outStream;
	[SEG_ES:EBX] = DL;
	EDX = work->nowPos;
	EBX++;
	EDX++;
	work->outStream = EBX;
	work->nowPos = EDX;
	if ((unsigned) EDX < work->outSize)
		goto loophead;
fin:
	return;
err:
	INT(0x03);
state_table:
	DB(0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5);
}

/* 以上z0専用 */

/* 以下z1/z2用 */

void rdd_direct1b()
{
	EDX = 1;
}

void rdd_direct1()
/* EBP, ECX, ESI > EDX, ESI */
{
	STR_TEK5 *work == SS:EBP;
	unsigned int result == EDX, range == EDI, code == EAX;
	unsigned char *src == DS:ESI;
	range = work->range;
	code = work->code;
	do {
		if ((unsigned) range < 0x01000000)
			goto shift;
shift1:
		range >>= 1;
		CMP(code, range); /* >= なら CF = 0 */
		if ((unsigned) >=)
			code -= range; /* 相変わらずCF = 0 */
		RCL(result, 1);
		ECX--;
	} while (!= 0);
	work->range = range;
	work->code = code;
	return;
shift:
	code <<= 8;
	range <<= 8;
	LODSB();
	if ((unsigned) range >= 0x01000000)
		goto shift1;
	goto shift;
}

void setbm()
/* EBP, EDI */
/* EAX, ECX, EDXは破壊 */
{
//	STR_BITMODEL *bm == SS:EBP + EDI;
	STR_BITMODEL *bm == SS:EBP;
	CL = aBM.t;
	EAX |= -1;
	SHL(EAX, CL); /* EAX = -1 << t; */
	CL = aBM.m;
	EDX = EAX;
	aBM.tmsk = EAX; /* tmsk = -1 << t; */
	SHL(EDX, CL); /* EDX = -1 << (m + t); */
	ECX = EAX;
	NEG(EAX); /* EAX = 1 << t; */
	ECX &= 0xffff;
	EAX |= EDX; /* EAX = -1 << (m + t) | 1 << t; */
	NOT(EDX); /* EDX = ‾(-1 << (m + t)); */
	EAX &= ECX;
	EDX &= ECX;
	aBM.prb1 = EAX;
	aBM.prb0 = EDX;
	EAX -= EDX;
	aBM.prb01 = EAX;
	return;
}

void rdd_probtree1()
{
	EDX = 1;
}

void rdd_probtree()
/* rangeとcodeはworkから参照 */
/* EDIは破壊される EBXはキープされる */
{
	unsigned int bound == EAX, prob == EBX, tmp == EDX, result == EDX;
//	STR_BITMODEL *bm == SS:EBP + EDI;
	STR_BITMODEL *bm == SS:EBP;
	STR_TEK5 *work == SS:EBP;

//	EBP, EDI, work->range, work->code, EDX, ESI, CH
	do {
		PUSH(EBX); /* prob0 */
		EBX += result;
		PUSH(EBX);
		PUSH(result);
		aBM.lt--;
		EDX = [SS:EBP + EBX * 4];
		if ((signed) <= 0)
			goto bm_timeout0;
		/* lt=0もこれで分岐して毎回元に戻す...のではなく、lt0の最上位か何かをフラグにさせよう */
bm_timeout1:
		prob = EDX;
		EDX -= aBM.prb0; /* もしprb0よりも小さければ、この時点ででかい値になる */
		prob &= aBM.tmsk;
		EAX = work->range; /* スタックから拾ってもいいが */
		if ((unsigned) EDX > aBM.prb01)
			goto fixprob0;
fixprob2:
		if ((unsigned) EAX < 0x01000000)
			goto shift;
shift1:
		MUL(prob);
		CL = aBM.m;
		SHRD(bound, EDX, 16);
		tmp = prob;
		if ((unsigned) work->code < bound) {
			work->range = bound;
			prob += aBM.tmsk;
			tmp -= 0x10000 + 1;
			bound = 0;
		}
		SAR(tmp, CL);
		work->code -= bound;
		tmp &= aBM.tmsk; /* tmskの上位は1（そうでないと負の値がおかしくなる） */
		work->range -= bound;
		prob -= tmp; /* CFにデコード結果 */
		POP(result);
		POP(EAX);
		RCL(result, 1);
		[SS:EBP + EAX * 4] = prob;
		AL = CH;
		CH--;
		(unsigned char) AL >>= 4;
		POP(EBX);
		AL &= CH;
		CMP(AL, 1); /* TEST(AL, CH);の結果が0ならCF=1 */
		SBB(EAX, EAX);
		EAX &= 32;
		EDI += EAX;
		TEST(CH, 0x07); /* このために、8回以上のループはできない */
	} while (!= 0);
	TEST(result, result);
	return;
shift:
	EDX = EAX;
	EAX = work->code;
	do {
		EDX <<= 8; /* range */
		EAX <<= 8;
		LODSB();
	} while ((unsigned) EDX < 0x01000000);
	work->code = EAX;
	work->range = EDX;
	EAX = EDX;
	goto shift1;
fixprob0:
	prob = aBM.prb0;
	if ((signed) EDX >= 0)
		prob += aBM.prb01;
	goto fixprob2;
bm_timeout0:
	EBX = aBM.lt0;
	if ((signed) EBX >= 0) {
		PUSH(EDX);
		aBM.lt = EBX;
		PUSH(ECX);
		EBX = 320 + 64 /* &rd->probs.fchglt */;
		PUSH(EDI);
		EDX = 0;
		EDI = 32 + 96 /* &rd->bm[3] */;
		CH = 0x71;
		rdd_probtree(); /* == 1 */
		if (== 0)
			goto err;
		POP(EBX);
		EDI = EBX;
		EBX -= 32 /* &rd->bm[0] */;
		PUSH(EDI);
		EBX /= 16;
		EDX = 0;
		BL |= aBM.s;
		EDI = 32 + 32 /* &rd->bm[1] */;
		EBX += 320 + 0 /* rd->probs.fchgprm */;
		CH = 0x71;
		rdd_probtree();
		POP(EDI);
		aBM.s = DL;
		if (== 0) {
			PUSH(EDI);
			EBX = 320 + 1600 - 1 /* rd->probs.tbmt - 1 */;
			EDI = 32 + 64 /* &rd->bm[2] */;
			CH = 0x74;
			rdd_probtree1();
			POP(EDI);
			DL &= 0x0f;
			aBM.t = DL;
			if (DL == 15)
				goto err;
			PUSH(EDI);
			EBX = 320 + 1616 - 1 /* rd->probs.tbmm - 1 */;
			EDI = 32 + 64 /* &rd->bm[2] */;
			CH = 0x74;
			rdd_probtree1();
			POP(EDI);
			DL &= 0x0f;
			if (== 0)
				goto err; /* m==0はリザーブ */
			aBM.m = DL;
			DL += aBM.t;
			if ((unsigned) DL > 15)
				goto err;
			setbm(); /* EDI */
		}
		POP(ECX);
		POP(EDX);
		goto bm_timeout1;
	}
	aBM.lt = 0x7fffffff;
	goto bm_timeout1;
err:
	INT(0x03);
}

void rdd_probtree1_f()
{
	EDX = 1;
}

void rdd_probtree_f()
/* rangeとcodeはworkから参照 */
/* "EDIは破壊される" EBXはキープされる */
/* BM不変型, CHにカウンタ(上位は0) */
{
	unsigned int bound == EAX, prob == EBX, tmp == EDX, result == EDX;
//	STR_BITMODEL *bm == SS:EBP + EDI;
	STR_BITMODEL *bm == SS:EBP;
	STR_TEK5 *work == SS:EBP;

//	EBP, EDI, work->range, work->code, EDX, ESI, CH

	PUSH(ESI);
	PUSH(EBX); /* prob0 */
	EAX = aBM.prb01;
	EBX = aBM.prb0;
	PUSH(EAX);
	PUSH(EBX);
	EBX = (unsigned char) CH;
	EAX = aBM.lt;
	CL  = aBM.m;
	EAX -= EBX;
	ESI = aBM.tmsk;
	if ((signed) <= 0)
		goto slow;
	aBM.lt = EAX;
	/* これ以降ESI,EDIはどうでもいい */
	int tmsk == ESI, code == EDI;
	code = work->code;
	do {
		EBX = [SS:ESP + 8]; /* prob0 */
		PUSH(result);
		EBX += result;
		EAX = work->range;
		PUSH(EBX);
		EDX = [SS:EBP + EBX * 4];
		prob = EDX;
		EDX -= [SS:ESP + 8]; /* aBM.prb0 */
		prob &= tmsk;
		if ((unsigned) EDX > [SS:ESP + 12] /* aBM.prb01 */)
			goto fixprob0;
fixprob2:
		if ((unsigned) EAX < 0x01000000)
			goto shift;
shift1:
		MUL(prob);
		SHRD(bound, EDX, 16);
		tmp = prob;
		if ((unsigned) code < bound) {
			work->range = bound;
			tmp -= 0x10000 + 1;
			bound = 0;
			prob += tmsk;
		}
		SAR(tmp, CL);
		code -= bound;
		tmp &= tmsk;
		work->range -= bound;
		POP(EAX);
		prob -= tmp; /* CFにデコード結果 */
		POP(result);
		[SS:EBP + EAX * 4] = prob;
		RCL(result, 1);
		CH--;
	} while (!= 0);
	work->code = code;
	POP(EBX);
	POP(ESI);
	POP(EBX);
	POP(ESI);
	TEST(result, result);
	return;
shift:
	PUSH(ESI);
	EDX = EAX;
	ESI = [SS:ESP + 24];
	EAX = code;
	do {
		EDX <<= 8;
		EAX <<= 8;
		LODSB();
	} while ((unsigned) EDX < 0x01000000);
	[SS:ESP + 24] = ESI;
	code = EAX;
	work->range = EDX;
	POP(ESI);
	EAX = EDX;
	goto shift1;
fixprob0:
	prob = [SS:ESP + 8]; /* aBM.prb0 */
	if ((signed) EDX < 0)
		goto fixprob2;
	prob += [SS:ESP + 12]; /* aBM.prb01 */
	goto fixprob2;
slow:
	POP(EBX);
	POP(ESI);
	POP(EBX);
	POP(ESI);
	CH |= 0x70;
	asmout("JMP rdd_probtree");
}

/*
	  +0:lensel0
	  +8:lensel1
	  +0:low(16*8)
	+128:mid(16*8)
	+256:high(256)
	+512:
*/

void getlen1()
/* EBXにprob0, EDX:posState */
/* EDXに返す */
{
	STR_TEK5 *work == SS:EBP;
	EDX *= 8;
	EDI = work->ptbm[12];
	PUSH(EDX);
	CH = 0x01;
	EDX = 0;
	rdd_probtree_f();
	if (!= 0) {
		POP(EDX);
		EDI = work->ptbm[16];
		CH = 0x03;
		EBX += EDX;
		rdd_probtree1_f();
		EDX -= 8;
		return;
	}
	EDI = work->ptbm[12];
	EBX -= -128;
	CH = 0x01;
	EDX = 0;
	rdd_probtree_f();
	POP(EDX);
	if (!= 0) {
		EDI = work->ptbm[20];
		CH = 0x03;
		EBX += EDX;
		goto rdd_probtree1_f;
	}
	EDI = work->ptbm[24];
	EBX -= -128;
	CH = 0x08;
	rdd_probtree1_f();
	EDX -= 248 + 256;
	if ((unsigned) > 0) {
		if ((unsigned) EDX < 6) {
			EDI = work->ptbm[28];
			EBX = 0;
			CL = DL;
			EBX++;
			CH = DL;
			SHL(EBX, CL);
			EBX += 320 + 66 - 2; /* lenext */
			rdd_probtree1_f();
		} else {
			ECX = EDX;
			rdd_direct1b();
		}
		LEA(ECX, [EDX - 1]);
		rdd_direct1b();
		EDX--;
	}
	EDX += 16 + 248;
	return;
}

void decodemain1()
/* EBP */
{
	STR_TEK5 *work == SS:EBP;
	ESI = work->p;
	EDI = work->ptbm[0];
	EBX = 320 + 1632; /* mch */
	CH = 0x01;
	EDX = 0;
	rdd_probtree_f(); /* これは1になる */
	if (== 0)
		goto err;
	EDI = 32 + 768; /* bm[24] */
	EBX = 320 + 2064; /* lit0 */
	CH = work->lit0cntmsk;
	rdd_probtree1();
	EDI = work->outStream;
	XCHG(EAX, EDX);
	STOSB();
	EDX = work->nowPos;
	work->outStream = EDI;
	if ((unsigned) EDX >= work->outSize)
		goto fin;
mainloop:
	EBX = work->state;
	EDI = work->ptbm[4];
	EDX &= work->posStateMask;
	EBX *= 16;
	if (== 0)
		EDI = work->ptbm[0];
	PUSH(EDX); /* posState */
	LEA(EBX, [EBX + EDX + 320 + 1632]); /* mch */
	CH = 0x01;
	EDX = 0;
	rdd_probtree_f();
	if (!= 0) { /* lit0 */
		POP(EDX);
		EBX = work->state;
		EDX = work->nowPos;
		EDI = work->outStream;
	//	BL = [SEG_CS:state_table + EBX];
		asmout("MOV BL,[CS:.state_table+EBX]");
		EDX &= work->literalPosMask;
		(char) work->state = BL;
		CL = work->lc;
		EBX = (unsigned char) [SEG_ES:EDI - 1];
		SHL(EDX, CL);
		PUSH(EDI);
		CL = work->lc8;
		SHR(EBX, CL);
		EBX += EDX;
		EDI = 32 + 768; /* bm[24] */
		EBX *= 256;
		CH = work->lit0cntmsk;
		EBX += 320 + 2064; /* lit0 */
		if (CH == 0x78) {
			CH = 0x08;
			rdd_probtree1_f();
		} else if (CH == 0x38) {
			CH = 0x04;
			rdd_probtree1_f();
			CH = 0x04;
			EDI = 32 + 800; /* bm[25] */
			rdd_probtree_f();
		} else
			rdd_probtree1();
lit11:
		POP(EDI);
		AL = DL;
		EDX = work->nowPos;
		STOSB();
		EDX++;
		work->outStream = EDI;
		work->nowPos = EDX;
		if ((unsigned) EDX < work->outSize)
			goto mainloop;
		goto fin;
	}
	/* LZ */
lzphase:
	EBX = work->state;
	EDI = work->ptbm[52];
	EBX += 320 + 2016; /* rep */
	EDX = 0;
	PUSH(EDI);
	CH = 0x01;
	rdd_probtree_f();
	POP(EDI);
	if (== 0) { /* repなLZ */
		EBX += 12; /* repg0 */
	//	EDX = 0;
		PUSH(EDI);
		CH = 0x01;
		rdd_probtree_f();
		POP(EDI);
		if (!= 0) { /* rep[0] */
			EBX = work->state;
			POP(EDX);
			EBX *= 16;
			PUSH(EDX);
			LEA(EBX, [EBX + EDX + 2144]); /* 320 + 1632 + 12 * 16 */
			EDX = 0;
			PUSH(EDI);
			CH = 0x01;
			rdd_probtree_f();
			POP(EDI);
			ECX = work->repdis[0];
			if (== 0) { /* rep[0], len = 1; */
				AL = (char) work->state;
				POP(EDX);
				CMP(AL, 7);
				EDX = work->repdis[0];
				SBB(AL, AL); /* -1, 0 */
				AL &= -2;
				AL += 11; /* 9, 11 */
				EDX = ECX;
				(char) work->state = AL;
				ECX |= -1;
				goto rep0l1skip;
			}
		} else {
			EBX += 12; /* repg1 */
			EDX = 0;
			PUSH(EDI);
			CH = 0x01;
			rdd_probtree_f();
			ECX = work->repdis[4];
			POP(EDI);
			if (== 0) { /* rep[1]ではない */
				EBX += 12; /* regp2 */
			//	EDX = 0;
				CH = 0x01;
				rdd_probtree_f();
				ECX = work->repdis[8];
				if (== 0) { /* rep[2]ではない */
					EDI = 32 + 704; /* bm[22] */
					EBX = 320 + 65; /* repg3 */
				//	EDX = 0;
					CH = 0x01;
					rdd_probtree_f();
					EAX = work->repdis[ 8];
					ECX = work->repdis[12];
					work->repdis[12] = EAX;
				}
				EAX = work->repdis[4];
				work->repdis[8] = EAX;
			}
			EDX = work->repdis[0];
			work->repdis[0] = ECX;
			work->repdis[4] = EDX;
		}
		AL = (char) work->state;
		CMP(AL, 7);
		POP(EDX); /* posState */
		SBB(AL, AL); /* -1, 0 */
		AL &= -3;
		PUSH(ECX);
		AL += 11; /* 8, 11 */
		EBX = 320 + 512; /* len0 */
		(char) work->state = AL;
		getlen1();
		ECX = EDX;
		POP(EDX);
	} else { /* 非repなLZ */
		EAX = work->repdis[8];
		EDX = work->repdis[4];
		EBX = work->repdis[0];
		work->repdis[12] = EAX;
		work->repdis[ 8] = EDX;
		AL = (char) work->state;
		work->repdis[ 4] = EBX;
		CMP(AL, 7);
		POP(EDX); /* posState */
		SBB(AL, AL); /* -1, 0 */
		AL &= -3;
		AL += 10; /* 7, 10 */
		EBX = 320 + 1024; /* len1 */
		(char) work->state = AL;
		getlen1();
		EBX = EDX;
		PUSH(EDX); /* len */
		EDI = work->ptbm[32];
		if ((unsigned) EBX >= 3) {
			EBX = 3;
			EDI = work->ptbm[36];
		}
		EBX *= 64;
		CH = 0x06;
		EBX += 320 + 256; /* pslot */
		rdd_probtree1_f();
		EDX &= 0x3f;
		if (EDX >= 4) {
			ECX = EDX;
			EBX = EDX;
			(unsigned int) ECX >>= 1;
			EDX = 1;
			ECX--; /* CF不変 */
			RCL(EDX, 1);
			if ((unsigned) EBX < 14) {
				/* リバースでECXビットをEDXに押し込む */
				PUSH(EDX);
				SHL(EDX, CL);
				NOT(EBX);
				PUSH(ECX);
				EDI = work->ptbm[40];
				CH = CL;
				LEA(EBX, [EBX + EDX + 448]); /* spdis */
				if (CL >= 4)
					EDI = work->ptbm[44];
				rdd_probtree1_f();
				POP(ECX);
			} else {
				ECX -= 6;
				if ((unsigned) > 0)
					rdd_direct1();
				EDI = work->ptbm[48];
				CH = 0x06;
				EBX = 320 + 1536; /* align */
				PUSH(EDX);
				rdd_probtree1_f();
				CL = 6;
			}
			EBX = EDX;
			POP(EDX);
			do {
				(unsigned int) EBX >>= 1;
				RCL(EDX, 1);
				CL--;
			} while (!= 0);
		}
		NOT(EDX);
		POP(ECX); /* len */
		work->repdis[0] = EDX;
	}

rep0l1skip:
	PUSH(EDI);
	ECX += 2;
	PUSH(ESI);
	EDI = work->outStream;
	ESI = work->outSize;
	ESI -= work->nowPos;
	if ((unsigned) ECX >= ESI)
		ECX = ESI;
	LEA(ESI, [EDI + EDX]);
	work->nowPos += ECX;
	if ((unsigned) ESI < work->q0)
		goto err;
	asmout("REP ES MOVSB");
	work->outStream = EDI;
	POP(ESI);
	EDX = work->nowPos;
	POP(EDI);
	if ((unsigned) EDX >= work->outSize)
		goto fin;
lzdone:
	EBX = work->state;
	EDI = work->ptbm[4];
	EDX &= work->posStateMask;
	EBX *= 16;
	if (== 0)
		EDI = work->ptbm[0];
	PUSH(EDX); /* posState */
	LEA(EBX, [EBX + EDX + 320 + 1632]); /* mch */
	CH = 0x01;
	EDX = 0;
	rdd_probtree_f();
	if (== 0)
		goto lzphase;

	POP(EDX);
	EBX = work->state;
	EDX = work->nowPos;
	EDI = work->outStream;
//	BL = [SEG_CS:state_table + EBX];
	asmout("MOV BL,[CS:.state_table+EBX]");
	EDX &= work->literalPosMask;
	(char) work->state = BL;
	CL = work->lc;
	EBX = (unsigned char) [SEG_ES:EDI - 1];
	SHL(EDX, CL);
	PUSH(EDI);
	CL = work->lc8;
	SHR(EBX, CL);
	EBX += EDX;
	EDX = work->repdis[0];
	EBX *= 256;
	CL = [SEG_ES:EDI + EDX];

	PUSH(EBX);
	EDX = 0;
	EBX *= 2; /* 512 */
	EDX++; /* EDX = 1 */
	EBX += work->lit1;
	AL = work->lit0cntmsk;
	EDI = 32 + 768; /* bm[24] */
	do {
		ECX *= 2;
		PUSH(EBX);
		PUSH(ECX);
		PUSH(EDI);
		PUSH(EAX);
		ECX &= 0x100;
		EDI = work->ptbm[8];
		EBX += ECX;
		CH = 0x01;
		rdd_probtree_f();
		POP(EAX);
		POP(EDI);
		CL = AL;
		EAX--;
		(unsigned char) CL >>= 4;
		TEST(AL, CL);
		if (== 0)
			EDI += 32;
		POP(ECX);
		AH = DL;
		POP(EBX);
		AH ^= CH;
		if (EDX >= 0x100)
			goto finlit1;
		TEST(AH, 1);
	} while (== 0);
	CH = AL;
	POP(EBX);
	EBX += 320 + 2064; /* lit0 */
	if (AL > 0x70) {
		CH &= 0x0f;
		rdd_probtree_f();
		goto lit11;
	}
	rdd_probtree();
	goto lit11;
finlit1:
	POP(EBX);
	goto lit11;
err:
	EAX = 0;
	ESP = [SS:EBP - 4];
	EAX++;
fin:
	return;
state_table:
	DB(0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5);
}

void cmd0004_decode_tek5()
/* DS:ESI(limit:EDX), ES:EDI, EBP */
{
	PUSHFD();
	CLD();
	getnum_s7s();
	TEST(AL, 0x01);
	if (!= 0)
		INT(0x03); /* 手抜きエラー */
	ESI--;
	if (EBP != 0)
		lzrestore_tek5();
	POPFD();
	return;
}

void cmd008()
/* pioneer0ライブラリの終了
   オプションで、アプリ自体も終了するか、それともアプリは終了しないかを選べる
   現在は、オプションを確認することもなく、終了 */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	(offset) cmd += 8;
	PUSH((int) 0);
	PUSH((int) 0x0001); // opt(close all handle)
	PUSH((int) 0x0040); /* タスク終了 */
	EBX = ESP;
	CALL(0x0017,0); /* GUIGUI統合shellcall */
	AL = [SS:ESP + 6];
	ESP += 12 - 4;
	AL += work->ending_count;
	AL &= 0x7f;
	work->ending_count = AL;
	if (!= 0) {
		/* sleep */
		LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更する) */
	//	work->softint_mask_buf[ 8] = 0x0080;
		(int) [DS:EBX + 8] = 0x0080;
		CALL(0x0017,0); // shell-call
		INT(0x03);
	}
//	PUSH((int) 0);
	PUSH((int) 0x0002); // opt(close task)
	PUSH((int) 0x0040); /* タスク終了 */
	EBX = ESP;
	CALL(0x0017,0); /* GUIGUI統合shellcall */
	INT(0x03);
}

void cmd00c()
/* JMP */
{
	int *cmd == DS:ESI;
	EAX = cmd[4]; /* opt */
	if (EAX == 0) {
		/* 相対ジャンプ */
		(offset) cmd += cmd[8];
		asmout("JMP nextcmd");

	}
	if (EAX == 1) {
		/* 絶対ジャンプ */
		(offset) cmd = cmd[8];
		asmout("JMP nextcmd");
	}
	SAFE_CUT("DB ..$-$-1,'jump:Invalid option ',0,'@',6,'.'");
}

void cmd010()
/* softintベクタ設定 */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[4] /* EIP */;
	ECX = cmd[8] /* CS */;
	(offset) cmd += 12;
	work->softint_EIP = EAX;
	work->softint_CS = ECX;
	asmout("JMP nextcmd");
}

void cmd014()
/* 各種info取得 : cmd, opt, ptr */
/* lenなどはoptで決まるので書かなくてよい */
{
	int *cmd == DS:ESI;
	if (cmd[4] != 0x10) {
		SAFE_CUT("DB ..$-$-1,'getInfo:Invalid option ',0,'@',6,'.'");
	}
	PUSH(0x0000);
	PUSH(cmd[12]);
	PUSH(cmd[ 8]);
	PUSH(0);
	PUSH(2);
	PUSH(0);
	PUSH(0x0210);
	EBX = ESP;
	CALL(0x0017,0); /* GUIGUI統合shellcall */
	ESP += 28;
	PUSH(DS);
	LDS(EBX, cmd[8]);
	(int) [DS:EBX + 0] -= 8 + 8;
	(int) [DS:EBX + 4] -= 29 + 8;
	POP(DS);
	(offset) cmd += 16;
	asmout("JMP nextcmd");
}

void near cmd018()
/* wait signal */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	EAX = cmd[8]; // signaldw
	EDX = cmd[4]; // opt
	work->signalbox_write_free += EAX;
	work->signalbox_read_free -= EAX;
	if ((unsigned) < 0) {
		/* 書き込んだ以上に、読み込んだと報告された。
		   これは許しがたいエラーである。 */
		SAFE_CUT("DB ..$-$-1,'waitSignal:Signal received more than sent.'");
	}
//	ECX = work->signalbox_write_ptr;
//	TEST(CL, 0x01);
	TEST((char) work->signalbox_write_ptr, 0x01);
	PUSH((int) 0x0000); /* eoc */
	if (!= 0) {
		if (EAX != 0) {
			/* シグナルフルだったので、それを解除 */
			work->signalbox_write_ptr &= 0xfffffffc;
		//	PUSH((int) 0x0000); // eoc
			PUSH((int) 0xff02); // nest
			PUSH((int) 0); // signals
			PUSH((int) 0x0204); // add nest
			EBX = ESP;
			CALL(0x0017,0); /* GUIGUI統合shellcall */
			ESP += 16 - 4;
		}
	}
	if (EDX == 0x0080) {
		/* 帰還要求を表すために、スタック内のESP値を1にする。 */
		(int) [SS:ESP + 12 /* ESP */ + 4] = 1;
	}
	EAX = cmd[12]; // nest
	work->nest += EAX;

	(offset) cmd += 16;
	TEST(EDX, 0xffffff70);
	if (!= 0) {
		// 無効オプション指定
		SAFE_CUT("DB ..$-$-1,'waitSignal:Invalid option ',2,'.'");
	}

	int slot == EAX;
	slot = 0x01c0;

	TEST(DL, 0x08);
	if (!= 0) {
		// set now time
	//	PUSH((int) 0x0000);
		PUSH((int) /* 0x01c0 */ slot);
		PUSH((int) 0x0310); /* 現在時刻設定 */
		EBX = ESP;
		CALL(0x0017,0); /* shell-call */
		ESP += 12 - 4;
	}

	TEST(DL, 0x04);
	if (!= 0) {
		/* add time */
		/* 本来なら最低加算時間のチェックがある */
	//	PUSH((int) 0x0000);
		PUSH(cmd[8]);
		PUSH(cmd[4]);
		PUSH(cmd[0]);
		(offset) cmd += 12;
		PUSH((int) /* 0x01c0 */ slot);
		PUSH((int) 0x0314); /* 時刻加算 */
		EBX = ESP;
		CALL(0x0017,0); // shell-call
		ESP += 24 - 4;
	}

	/* 以下はシグナルが溜まっていないときだけ有効 */
	if (work->signalbox_read_free == 0) {
		TEST(DL, 0x02);
		if (!= 0) {
			// regist timer
		//	PUSH((int) 0x0000);
			PUSH((int) /* 0x01c0 */ slot);
			PUSH((int) 0x0308); /* タイマー登録 */
			EBX = ESP;
			CALL(0x0017,0); // shell-call
			ESP += 12 - 4;
		}
		TEST(DL, 0x01);
		if (!= 0) {
			/* sleep */
			LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更する) */
			work->softint_mask_buf[ 8] = 0x0080;
			CALL(0x0017,0); // shell-call

			LEA(EBX, work->softint_mask_buf[0]); /* add_nest(Llv変更しない) */
			work->softint_mask_buf[ 8] = 0xff80;
				/* ライブラリルーチン内に再入したので、割り込みマスク */
			CALL(0x0017,0); // shell-call
		}
		TEST(DL, 0x02);
		if (!= 0) {
			/* cancel timer */
		//	PUSH((int) 0x0000);
			PUSH((int) /* 0x01c0 */ slot);
			PUSH((int) 0x030c); // タイマー解約
			EBX = ESP;
			CALL(0x0017,0); // shell-call
			ESP += 12 - 4;
		}
	}
	POP(EAX);
	asmout("JMP nextcmd");
}

void cmd01c()
/* NOP */
{
	int *cmd == DS:ESI;
	(offset) cmd += 4;
	asmout("JMP nextcmd");
}

void cmd020()
/* create new window.
   slotのbit0 : ユーザーシグナルハンドリング
   slotのbit1 : position offset指定
   今のところ、シグナル長1のみサポート */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	/* WINDOW構造体の初期化など */
	WINDOW *cmd0020_win == DS:EDI;
	(offset) cmd0020_win = cmd[ 4]; // work_ptr
	LEA(EAX, cmd0020_win->children_back); 
	cmd0020_win->children_back = EAX;
	cmd0020_win->children_next = EAX;
	LEA(EAX, cmd0020_win->chain_back);
	ECX = work->children_back;
	work->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, work->children_back);
	cmd0020_win->chain_back = ECX;
	cmd0020_win->chain_next = EAX;
	// signatureも初期化
	asmout("mov dword[ds:edi], 'WIND'");
	asmout("mov dword[ds:edi+4], 'OW00'");

	EAX = cmd[ 8]; // slot-no
	ECX = cmd[12]; // x-size
	EDX = cmd[16]; // y-size
	(offset) cmd += 20;
	TEST(AL, 0x01);
	(int) cmd0020_win->mode0 = 0;
	cmd0020_win->flags = 0;
	if (!= 0) {
		/* シグナルハンドリング */
		EBX = cmd[0];
		TEST(BH, 0x01);
		if (!= 0)
			BH ^= 0x10;
		(short) cmd0020_win->siglen = BX;
		/* シグナル長(bit0-3), ハンドリング範囲(bit8-15)
		   値0 : ハンドリングしない
		   bit0 : enable(0)/disable(1)/redraw(2)/redraw2(3)
		   bit1 : move(4)
		   bit2 : setmode(5)
		   bit3 : close(6)
		   bit4 : opt for bit0
		   bit5 : closed(7)
		   bit6 : resize(8)
		   bit7は加算量scale(0はx1、1はx4)
		   残りの4bitはリザーブ
		   最小化はdisableで処理されるので、検知できない
		   clickやresizeは拡張系(8, 9) */
		EBX = cmd[4];
		(offset) cmd += 8;
		cmd0020_win->signalhead[0] = EBX;
	}
	TEST(AL, 0x02);
	if (== 0) {
		ECX += 8 + 8; /* 左右に8dotずつ確保 */
		EDX += 29 + 8; /* 上に29dot、下に8dot確保 */
		cmd0020_win->x_ofs =  8;
		cmd0020_win->y_ofs = 29;
	} else {
		PUSH(EDX);
		EDX = cmd[0]; // x-offset
		EBX = cmd[4]; // y-offset
		(offset) cmd += 8;
		cmd0020_win->x_ofs = EDX;
		cmd0020_win->y_ofs = EBX;
		POP(EDX);
		cmd0020_win->flags |= WINFLAG_USERCONTROL;
	}
	EAX &= 0xfffffff0;
	cmd0020_win->x_size = ECX;
	cmd0020_win->y_size = EDX;
	cmd0020_win->slot = EAX;
	PUSH((int) 0 /* EOC */);
	PUSH((int) 0x0040 /* signal-base */);
	PUSH((int) 0x0140 /* signalbox(slot番号で指定) */);
	PUSH(EDX /* y-size */);
	PUSH(ECX /* x-size */);
	PUSH((offset) cmd0020_win /* user-no */);
	PUSH(EAX /* slot-no */);
	PUSH((int) 0x0100 /* cmd-no */);
	EBX = ESP;
	CALL(0x0017,0); // shell-call
	ESP += 32;
	asmout("JMP nextcmd");
}

void cmd024()
/* windowクローズ */
/* これにつながっていた全てのコンポーネントも使えなくなる */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *cmd0024_win == DS:EDI;
	(offset) cmd0024_win = cmd[ 8]; // work_ptr
	(offset) cmd += 12;
	PUSH((int) 0 /* EOC */);
	PUSH(cmd0024_win->slot);
	PUSH((int) 0x0104 /* cmd-no */);
	[DS:EDI] = EDI;
	[DS:EDI+4] = EDI;	/* signatureつぶし */
	EBX = ESP;
	CALL(0x0017,0); // shell-call
	ESP += 12;
	work->ending_count++;
	asmout("JMP nextcmd");
}

void cmd028()
// open text box
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;

	WINDOW *win == DS:EDI;
	TEXTBOX *textbox == DS:EBX;
	(offset) textbox = cmd[ 8]; // work_ptr
	(offset) win = cmd[32]; // window
	/* 新しいtextboxをchainの一番後ろにつなぐ */
	(int) textbox->signature[0] = 0x54584554; // 'TEXT'
	LEA(EAX, textbox->chain_back);
	ECX = win->children_back;
	win->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, win->children_back);
	textbox->chain_back = ECX;
	textbox->chain_next = EAX;
	textbox->flags = 0;
	EAX = cmd[ 4]; // opt
	ECX = cmd[12]; // bcolor
	TEST(AL, 0x01);
	if (== 0) {
		ECX = DEFAULT_TBOX_BCOL;
		// titleの時は、アクティブかどうかによって色が変わるので、初期値を設定しない
	}
	textbox->backcolor = ECX;
	EDX = cmd[24]; // x0
	ECX = cmd[28]; // y0
	EDX += win->x_ofs;
	ECX += win->y_ofs;
	TEST(AH, 0xf0);
	if (!= 0) {
		/* ウィンドウタイトルサイズチェック */
		ECX = cmd[16]; // x_size(キャラクター数)
		ECX *= 8;
		ECX += 80 + 16;
		#if (defined(SAFEAPI_FLAG))
			if (win->x_size < ECX) {
				EAX = textbox->chain_back;
				LEA(EDI, win->children_back);
				[DS:EAX+4] = EDI;	/* win->back->back->next=win */
				[DS:EDI] = EAX;		/* win->back = win->back->back */
				/* 切らないで不正なまま残しておくと死亡 */
				SAFE_CUT("DB ..$-$-1,'opentextbox:Too long titlebox(WinW must be >=',1,').'");
			}
		#else
			if (win->x_size < ECX)
				INT(0x03);
		#endif
		EDX = 24;
		ECX =  4;
	}
	textbox->x0 = EDX;
	textbox->y0 = ECX;
	textbox->option = EAX;
	textbox->window = (offset) win;
	EAX = cmd[16]; // x_size(キャラクター数)
	ECX = cmd[20]; // y_size(キャラクター数)
	textbox->x_size = EAX;
	textbox->y_size = ECX;
	EDX = cmd[36]; // キャラクターセット(slot-no)
	ECX = cmd[40]; // space code.
	(offset) cmd += 44;
	textbox->blank = ECX;

	// バッファの初期化
	textbox->charset = EDX;
	EAX = textbox->x_size;
	PUSH((offset) textbox);
	MUL(textbox->y_size);
	EDX = textbox->backcolor;
	EDX <<= 16;
	(offset) textbox += 64;
	EDX++;
	do {
		(int) [textbox    ] = ECX;
		(int) [textbox + 4] = EDX;
		(offset) textbox += 8;
		EAX--;
	} while (!= 0);
	POP((offset) textbox);

	EAX = textbox->x_size;
	ECX = textbox->y_size;
	EAX *= 8;
	ECX *= 8;
	TEST(textbox->option, 0x10);
	if (== 0)
		ECX *= 2;
	EAX -= win->x_size;
	ECX -= win->y_size;
	if (EAX >= -16) { /* 8 + 8 */
		if (ECX >= -37) { /* 29 + 8 */
			TEST(win->flags, WINFLAG_USERCONTROL);
			if (== 0)
				win->flags |= WINFLAG_FRAMEONLY;
		}
	}
	/* x0, y0も調べるべきだが、手抜き */

	if (win->draw_enable != 0) {
		/* もし、描画フラグが1なら、更新する(フレームを描くとか、背景色をセットするとか)。 */
		EAX = textbox->option;
		TEST(AH, 0xf0);
		if (== 0) {
			TEST(AL, 0x01);
			if (!= 0) {
				EDX = win->slot;
				PUSH(ESI);
				ESI = (offset) textbox;
				// EDX:win_slot, ESI:textbox
				EAX = 0x0020;
				textbox_drawback();
				POP(ESI);
			}
		}
	} else
		textbox->flags |= WINFLAG_MUSTREDRAW;
	asmout("JMP nextcmd");
}

void cmd02c()
/* close text box */
/* cmd, opt, textbox */
{
	int *cmd == DS:ESI;
	WINDOW *win == DS:EDI;
	TEXTBOX *textbox == DS:EBX;
	(offset) textbox = cmd[8];
	(offset) cmd += 12;

	int *back == DS:EAX, *next == DS:ECX;
	(offset) back = textbox->chain_back;
	(offset) next = textbox->chain_next;
	(offset) win = textbox->window;
	back[4 /* next */] = (offset) next;
	next[0 /* back */] = (offset) back;
	win->flags &= -1-WINFLAG_FRAMEONLY;

	EAX = 0;
	if (AL != win->draw_enable) {
		/* もし描画フラグが1なら、消去する。 */
		PUSH(EAX);
		EAX = textbox->x0;
		ECX = textbox->y0;
		EDX = textbox->option;
		PUSH((int) 8);
		PUSH(EDX);
		PUSH(EDX);
		PUSH(ECX);
		PUSH(EAX);
		EAX = textbox->x_size;
		ECX = textbox->y_size;
		EAX *= 8;
		ECX *= 8;
		TEST(DL, 0x10);
		if (== 0)
			ECX *= 2;
		EAX += textbox->x0;
		ECX += textbox->y0;
		EAX--;
		ECX--;
		TEST(DL, 0x01);
		(int) [SS:ESP +  8] = EAX;
		(int) [SS:ESP + 12] = ECX;
		if (!= 0) {
			EAX += 3;
			ECX += 3;
			(int) [SS:ESP +  8] = EAX;
			(int) [SS:ESP + 12] = ECX;
			(int) [SS:ESP     ] -= 3;
			(int) [SS:ESP +  4] -= 3;
		}
		PUSH(win->slot);
		PUSH((int) 0x0020 /* boxfill */);
		PUSH((int) 0x0400 /* line cmd */);
		EBX = ESP;
		CALL(0x0017,0); // GUIGUI統合shellcall
		ESP += 36;
	} else
		win->flags |= WINFLAG_MUSTREDRAW;
		/* 塗り潰して消えるだけの特別なコンポーネントを作る手もなくはない */
	asmout("JMP nextcmd");
}

void cmd030()
// open graphic box
/* cmd, opt(0), graphbox */
/* cmd, opt(1), graphbox, mode, mode_opt, x_size, y_size, x0, y0, window */
/* cmd, opt(2), graphbox, mode, mode_opt, x_bsize, y_bsize,
	x_vsize, y_vsize, x0, y0, window */

/* optのbit15が1ならGAPIへコマンドは送らない */
/* optのbit12が1なら、バッファの初期化はしない */
/* 別のコマンドで、グラフィックコマンドの表示位置を設定する(controlgbox) */
{
	WORK *work == SS:EBP;
	int *cmd == DS:ESI;
	WINDOW *win == DS:EDI;
	GRAPHBOX *graphbox == DS:EBX;

	EAX = cmd[ 4]; // opt
	(offset) graphbox = cmd[ 8]; // work_ptr
	graphbox->flags = 0;
	if (AL == 0x01) {
		(offset) win = cmd[36]; // window
		EAX = cmd[12]; // mode
		ECX = cmd[16]; // mode_opt
		EDX = cmd[20]; // x_size
		graphbox->mode = AL;
		graphbox->mode_opt = ECX;
		graphbox->x_bsize = EDX;
		graphbox->x_vsize = EDX;
		EAX = cmd[24]; // y_size
		ECX = cmd[28]; // x0
		EDX = cmd[32]; // y0
		ECX += win->x_ofs;
		EDX += win->y_ofs;
		graphbox->y_bsize = EAX;
		graphbox->y_vsize = EAX;
		graphbox->x0 = ECX;
		graphbox->y0 = EDX;
		LEA(EAX, graphbox->buffer[0]);
		ECX = 0;
		PUSH((int) 40);
		graphbox->vbuf0 = EAX;
		graphbox->vx0 = ECX;
		graphbox->vy0 = ECX;
		graphbox->window = (offset) win;
		goto bufclear;
	} else if (AL == 0x02) {
		(offset) win = cmd[44]; // window
		EAX = cmd[12]; // mode
		ECX = cmd[16]; // mode_opt
		EDX = cmd[20]; // x_bsize
		graphbox->mode = AL;
		graphbox->mode_opt = ECX;
		graphbox->x_bsize = EDX;
		EAX = cmd[24]; // y_bsize
		ECX = cmd[28]; // x_vsize
		EDX = cmd[32]; // y_vsize
		graphbox->y_bsize = EAX;
		graphbox->x_vsize = ECX;
		graphbox->y_vsize = EDX;
		EAX = cmd[36]; // x0
		ECX = cmd[40]; // y0
		EAX += win->x_ofs;
		ECX += win->y_ofs;
		graphbox->x0 = EAX;
		graphbox->y0 = ECX;
		ECX = 0;
		LEA(EAX, graphbox->buffer[0]);
		PUSH((int) 48);
		graphbox->vbuf0 = EAX;
		graphbox->vx0 = ECX;
		graphbox->vy0 = ECX;
		graphbox->window = (offset) win;
bufclear:
		TEST((char) cmd[5], 0x10);
		if (== 0) {
			EAX = graphbox->x_bsize;
			MUL(graphbox->y_bsize);
			EDX = graphbox->vbuf0;
			ECX = graphbox->mode_opt;
			if (graphbox->mode == 0x22)
				goto clr_mode2;
			if (graphbox->mode == 0x24)
				goto clr_mode4;
			if (graphbox->mode == 1) {
				do {
					[DS:EDX] = CL;
					EDX++;
					EAX--;
				} while (!= 0);
			}
			if (graphbox->mode == 2) {
	clr_mode2:
				do {
					[DS:EDX] = CX;
					EDX += 2;
					EAX--;
				} while (!= 0);
			}
			if (graphbox->mode == 4) {
	clr_mode4:
				do {
					[DS:EDX] = ECX;
					EDX += 4;
					EAX--;
				} while (!= 0);
			}
		}
	} else {
		PUSH((int) 12);
		(offset) win = graphbox->window;
	}
	(offset) win = graphbox->window; // window
	(int) graphbox->signature[0] = 0x50415247; // 'GRAP'
	LEA(EAX, graphbox->chain_back);
	ECX = win->children_back;
	win->children_back = EAX;
	(int) [DS:ECX + 4] /* back->next */ = EAX;
	LEA(EAX, win->children_back);
	graphbox->chain_back = ECX;
	graphbox->chain_next = EAX;

	EAX = win->x_size;
	ECX = win->y_size;
	EAX -= graphbox->x_vsize;
	ECX -= graphbox->y_vsize;
	if (EAX <= 8 + 8) {
		if (ECX <= 29 + 8) {
			TEST(win->flags, WINFLAG_USERCONTROL);
			if (== 0)
				win->flags |= WINFLAG_FRAMEONLY;
		}
	}
	/* x0, y0も調べるべきだが、手抜き */

	/* 必要ならフレームを描く */
	TEST((char) cmd[ 5], 0x80);
	if (== 0) {
		if (win->draw_enable != 0) {
			EAX = graphbox->x_bsize;
			ECX = graphbox->mode;
			PUSH((int) 0);
			EAX -= graphbox->x_vsize;
			ECX &= 0x0f;
			PUSH(DS);
			IMUL(EAX, ECX);
			PUSH(graphbox->vbuf0);
			PUSH(EAX);
			PUSH(graphbox->y_vsize);
			PUSH(graphbox->x_vsize);
			PUSH(graphbox->y0);
			PUSH(graphbox->x0);
			PUSH(win->slot);
			EBX = graphbox->mode;
			PUSH(EBX);
			PUSH((int) 0x0414);
			EBX = ESP;
			CALL(0x0017,0); // GUIGUI統合shellcall
			ESP += 44;
		} else
			graphbox->flags |= WINFLAG_MUSTREDRAW;
	}
	POP(EAX);
	(offset) cmd += EAX;
	asmout("JMP nextcmd");
}

void cmd034()
/* close graphic box */
/* cmd, opt, graphicbox */
{
	SAFE_CUT("DB ..$-$-1,'closeGraphicbox:Not implemented.'");
}

void cmd040()
// put string
/* bit0 : bcolor */
/* bit1 : color-font */
/* bit8-9 : 0,1,2,3(4) */
/* bit10 : col無効化 */
/* bit11 : bcol無効化 */
/* bit12-13 : dw|by|wd|dw */
/* bit14 : far-ptr */
{
	int *cmd == DS:ESI;
	WINDOW *win == DS:EDI;
	TEXTBOX *textbox == DS:EBX;
	TEXTBOX *textbox2 == DS:ECX;

	PUSH(ES);
	PUSH(DS);
	(offset) textbox = cmd[16];
	EAX = cmd[12]; // y_pos
	POP(ES);
	EDI = cmd[ 8]; // x_pos
	MUL(textbox->x_size);
	PUSH(EBP);
	ESP -= 52;
	EAX += EDI; // x_pos
	EBP = ESP;
	EDX = cmd[12]; // y_pos
	ECX = textbox->option;
	EDX *= 8;
	EDI *= 8;
	TEST(CL, 0x10); // option
	if (== 0)
		EDX *= 2;
	EDI += textbox->x0;
	EDX += textbox->y0;
	(int) [SS:EBP + 12] = EDI; /* x0 */
	(int) [SS:EBP + 16] = EDX; /* y0 */
	EDI = textbox->charset;
	(int) [SS:EBP +  4] = 0x3000; /* option */
	(int) [SS:EBP + 28] = EDI; /* charset */
	(offset) win = textbox->window;
	EDX = textbox->backcolor;
	PUSH((offset) textbox);
	LEA(EBX, [(offset) textbox + EAX * 8 + 64]); /* これ以降textboxは使えない */
	EAX = cmd[ 4]; /* option */
	TEST(AL, 0x01);
	if (!= 0)
		EDX = cmd[24]; // back_color
	TEST(CL, 0x10); /* half he