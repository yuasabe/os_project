/* "VESA32.ASK" for PC/AT ver.0.4 copyright(C) 2004 川合秀実 */

segment CODE(USE32, PARA);
default(code == CODE);

struct GAPI_WORK {
	signed int mx, my, mx0, my0, mx1, my1;
	int cursor_addr, pattern_addr;
	unsigned int lockcount, mouselock; /* +32 */
	char mouseflag, maskflag, mouseline, V86flag;
	int VGA_mode;
	int linebytes, x2, y2;
	unsigned char mouse_width, mouse_height, [2];
	short V86CS, V86SS;
	void [444];
	int backup_buf[1024];
	int mouse_pattern[2048]; /* 1536 */
	void [512]; /* フォント管理用ワーク */
	/* 以上4KB */
};

void far GAPI_entry()
/* 必ず、EFLAGS.IF == 1で呼ぶこと */
{
	goto syscmd;
//	ORG(0x0008);
//	ORG(0x0010);
	asmout("RESB 0x10-$");
	asmout("DD OFFSET #syscmd, 0, 0, 0");
	DD(4096); /* 初期化時に必要なワークエリアサイズ */
	DD(0); /* 最大ローカルスタック消費量 */
//	ORG(0x0040);
	asmout("RESB 0x40-$");
syscmd:
	GAPI_WORK *work == ES:0x0000;

	int all_sel == 1 * 8;
	int *cmd == FS:EBX;

	asmout("#GAPI_accesslock EQU GAPI_accesslock");
	asmout("#GAPI_mouse EQU GAPI_mouse");
	asmout("#GAPI_line EQU GAPI_line");
	asmout("#GAPI_fontwrite EQU GAPI_fontwrite");
	asmout("#GAPI_init EQU GAPI_init");
	asmout("#GAPI_resetdevice EQU GAPI_resetdevice");
	asmout("#GAPI_error EQU GAPI_error");
	asmout("#GAPI_putbox EQU GAPI_putbox");
	asmout("#GAPI_lineardots EQU GAPI_lineardots");
	asmout("#GAPI_points EQU GAPI_points");

	PUSH(DS);
	PUSH(ES);
	PUSHAD();
	PUSH(all_sel);
	POP(DS);
	MOV(ECX, CS);
	ECX += 8;
	ES = ECX;

asmout("next_command: EQU $");

	EAX = cmd[0];
	if (EAX == 0x0184)
		goto GAPI_accesslock;
	if (EAX == 0x0101)
		goto GAPI_fontwrite;
	if (EAX == 0x0108)
		goto GAPI_putbox;
	if (EAX == 0x0100)
		goto GAPI_line;
	if (EAX == 0x010c)
		goto GAPI_lineardots;
	if (EAX == 0x0110)
		goto GAPI_points;
	if (EAX == 0x0180)
		goto GAPI_mouse;
	if (EAX == 0x0010)
		goto GAPI_init;
	if (EAX == 0x001c)
		goto GAPI_resetdevice;
	if (EAX == 0x0104)
		goto fontload;
//	if (EAX == 0x0108)
//		goto allocarea; /* cmd, opt, size, (addr) */
	if (EAX == 0x0140)
		goto font_attr; /* cmd, opt, type, (param0), (param1), (param2), (param3) */

	if (EAX != 0)
		goto GAPI_error;

	[SS:ESP + 16] = EBX;
	POPAD();
	POP(ES);
	POP(DS);
	return;

fontload:
	/* cmd, opt, type, len, to, from */
	PUSH(DS);
	asmout("LDS ESI,DWORD FS:[EBX+20]");
	EAX = cmd[ 8]; /* type */
	ECX = cmd[12]; /* len */
	EDI = cmd[16]; /* to */
	(offset) cmd += 28;
	if (EAX <= 2) {
		/* mono, full/half */
		LEA(ECX, [ECX * 2]);
		if (!=)
			ECX *= 2;
		do {
			EAX = [DS:ESI];
			ESI += 4;
			[ES:EDI] = EAX;
			EDI += 4;
			ECX--;
		} while (!= 0);
		POP(DS);
		asmout("JMP next_command");
	}
	if (EAX <= 4) {
		/* EAX == 3:4bit color 8x16 */
		/* EAX == 4:4bit color 8x8 */
		LEA(ECX, [ECX * 8]);
		if (!=)
			ECX *= 2;
		do {
			EDX = [DS:ESI]; /* 8dots */
			ESI += 4;
			AH = DH;
			AL = DH;
			(unsigned char) AH >>= 4;
			EAX <<= 16;
			AH = DL;
			AL = DL;
			(unsigned char) AH >>= 4;
			EAX &= 0x0f0f0f0f;
			[ES:EDI] = EAX;
			(unsigned int) EDX >>= 16;
			AH = DH;
			AL = DH;
			(unsigned char) AH >>= 4;
			EAX <<= 16;
			AH = DL;
			AL = DL;
			(unsigned char) AH >>= 4;
			EAX &= 0x0f0f0f0f;
			[ES:EDI + 4] = EAX;
			EDI += 8;
			ECX--;
		} while (!= 0);
		POP(DS);
		asmout("JMP next_command");
	}
	INT(0x03);

font_attr:
	/* cmd, opt, type, (param0), (param1), (param2), (param3) */
	EAX = cmd[ 8]; /* type */
	asmout("MOV AL,BYTE PTR CS:[#font_attr_table+EAX-1]");
	(char) cmd[12] = AL;
	(offset) cmd += 28;
	asmout("JMP next_command");
font_attr_table:
	DB(4 /*  16bytes/font (8x16 mono) */);
	DB(3 /*   8bytes/font (8x 8 mono half height) */);
	DB(7 /* 128bytes/font (8x16 4bit color) */);
	DB(6 /*  64bytes/font (8x 8 4bit color half height) */);

//	DB(9 /* 512bytes/font (8x16 4bit color) */);
//	DB(8 /* 256bytes/font (8x 8 4bit color half height) */);
}

void colortable32()
{
	DD(0x00000000, 0x00840000, 0x00008400, 0x00848400);
	DD(0x00000084, 0x00840084, 0x00008484, 0x00848484);
	DD(0x00c6c6c6, 0x00ff0000, 0x0000ff00, 0x00ffff00);
	DD(0x000000ff, 0x00ff00ff, 0x0000ffff, 0x00ffffff);
}

void GAPI_fontwrite()
{
	/* 8x16のフォントを描画(背景色付き) */
	int *cmd == FS:EBX;
	GAPI_WORK *work == ES:0x0000;

	/* opt	bit0:full higth/half height
			bit1-7:	0000000 mono font col&bcol
					0000001 4bit color font
	*/

	EAX = cmd[4];
	if (AH != 0)
		goto opt_high;
	if ((unsigned) EAX >= 2)
		goto opt2;
	EAX = cmd[ 8]; /* x */
	ESI = cmd[12]; /* y */

	IMUL(ESI, work->linebytes);
	LEA(ESI, [ESI + EAX * 4 + 0xe0000000]);

	unsigned char *font == ES:EDI;
	unsigned int *font4 == ES:EDI;
	EAX = (unsigned char) cmd[20]; /* bgcolor */
	asmout("MOV EDX,[CS:colortable32+EAX*4]");
	EAX = (unsigned char) cmd[16]; /* color */
	asmout("MOV EBP,[CS:colortable32+EAX*4]");

	/* EBP:col, EDX:bgcol */
	PUSH(EBP); // 1
	PUSH(EDX); // 0

	int *string == FS:EBP;
	ECX = cmd[32]; // length

	if (cmd[4] != 0)
		goto opt1;

	LEA((offset) string, [EBX + 36]);
//	LEA(EBX, [EBX + ECX * 4 + 36]);

	do {
		PUSH(ECX);
		(offset) font = *string;
		(offset) string += 4;
		ECX = 16;
		PUSH(ESI);
		do {
			EBX = *font; /* 1lines */
			(offset) font++;
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 28] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 24] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 20] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 16] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 12] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI +  8] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI +  4] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			[DS:ESI +  0] = EAX;
			ESI += work->linebytes;
			ECX--;
		} while (!= 0);
		POP(ESI);
		POP(ECX);
		ESI += 4 * 8;
		ECX--;
	} while (!= 0);
//	ESP += 8;
	POP(EAX);
	POP(EAX);
	(offset) cmd = (offset) string;
	asmout("JMP next_command");

opt1:
	/* half height */
	LEA((offset) string, [EBX + 36]);
//	LEA(EBX, [EBX + ECX * 4 + 36]);

	do {
		PUSH(ECX);
		(offset) font = *string;
		(offset) string += 4;
		ECX = 8;
		PUSH(ESI);
		do {
			EBX = *font; /* 1lines */
			(offset) font++;
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 28] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 24] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 20] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 16] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI + 12] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI +  8] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			EDX = EBX;
			(unsigned int) EBX /= 2;
			EDX &= 0x01;
			[DS:ESI +  4] = EAX;

			EAX = [SS:ESP + EDX * 4 + 8];
			[DS:ESI +  0] = EAX;
			ESI += work->linebytes;
			ECX--;
		} while (!= 0);
		POP(ESI);
		POP(ECX);
		ESI += 4 * 8;
		ECX--;
	} while (!= 0);
//	ESP += 8;
	POP(EAX);
	POP(EAX);
	(offset) cmd = (offset) string;
	asmout("JMP next_command");

opt2:
	EAX = cmd[ 8]; /* x */
	ESI = cmd[12]; /* y */
//	TEST(AL, 0x03);
//	if (!= 0)
//		goto error; /* 4の倍数以外はまだサポートしてない */

	IMUL(ESI, work->linebytes);
	LEA(ESI, [ESI + EAX * 4 + 0xe0000000]);

//	int *font == ES:EDI;
//	int *string == FS:EBP;
	ECX = cmd[32]; // length

	if (cmd[4] != 2)
		goto opt3;
	INT(0x03);

	LEA((offset) string, [EBX + 36]);
//	LEA(EBX, [EBX + ECX * 4 + 36]);

	do {
		PUSH(ECX);
		(offset) font = *string;
		(offset) string += 4;
		ECX = 4;
		PUSH(ESI);
		do {
			EAX = font[ 0]; /* 2dots */
			EDX = font[ 4];
			[DS:ESI + 0] = EAX;
			[DS:ESI + 4] = EDX;
			ESI += work->linebytes;
			EAX = font[ 8]; /* 2dots */
			EDX = font[12];
			[DS:ESI + 0] = EAX;
			[DS:ESI + 4] = EDX;
			ESI += work->linebytes;
			EAX = font[16]; /* 2dots */
			EDX = font[20];
			[DS:ESI + 0] = EAX;
			[DS:ESI + 4] = EDX;
			ESI += work->linebytes;
			EAX = font[24]; /* 2dots */
			EDX = font[28];
			(offset) font += 32;
			[DS:ESI + 0] = EAX;
			[DS:ESI + 4] = EDX;
			ESI += work->linebytes;
			ECX--;
		} while (!= 0);
		POP(ESI);
		POP(ECX);
		ESI += 4 * 2;
		ECX--;
	} while (!= 0);
	(offset) cmd = (offset) string;
	asmout("JMP next_command");

opt3:
	/* half height */
	LEA((offset) string, [EBX + 36]);
//	LEA(EBX, [EBX + ECX * 4 + 36]);

	do {
		PUSH(ECX);
		(offset) font4 = *string;
		(offset) string += 4;
		ECX = 8;
		PUSH(ESI);
		do {
			EDX = font4[ 0]; /* 2dots */
			EAX = EDX;
			(unsigned int) EDX >>= 8;
			EAX &= 0x0f;
			EDX &= 0x0f;
			asmout("MOV EAX,[CS:colortable32+EAX*4]");
			asmout("MOV EDX,[CS:colortable32+EDX*4]");
			[DS:ESI +  0] = EAX;
			EAX = font4[ 0]; /* 2dots */
			[DS:ESI +  4] = EDX;
			EDX = EAX;
			(unsigned int) EAX >>= 16;
			(unsigned int) EDX >>= 24;
			EAX &= 0x0f;
			EDX &= 0x0f;
			asmout("MOV EAX,[CS:colortable32+EAX*4]");
			asmout("MOV EDX,[CS:colortable32+EDX*4]");
			[DS:ESI +  8] = EAX;
			[DS:ESI + 12] = EDX;
			EDX = font4[ 4]; /* 2dots */
			EAX = EDX;
			(unsigned int) EDX >>= 8;
			EAX &= 0x0f;
			EDX &= 0x0f;
			asmout("MOV EAX,[CS:colortable32+EAX*4]");
			asmout("MOV EDX,[CS:colortable32+EDX*4]");
			[DS:ESI + 16] = EAX;
			EAX = font4[ 4]; /* 2dots */
			[DS:ESI + 20] = EDX;
			EDX = EAX;
			(unsigned int) EAX >>= 16;
			(unsigned int) EDX >>= 24;
			EAX &= 0x0f;
			EDX &= 0x0f;
			asmout("MOV EAX,[CS:colortable32+EAX*4]");
			asmout("MOV EDX,[CS:colortable32+EDX*4]");
			[DS:ESI + 24] = EAX;
			[DS:ESI + 28] = EDX;
			(offset) font += 8;
			ESI += work->linebytes;
			ECX--;
		} while (!= 0);
		POP(ESI);
		POP(ECX);
		ESI += 4 * 8;
		ECX--;
	} while (!= 0);
	(offset) cmd = (offset) string;
	asmout("JMP next_command");

opt_high:
/*
	0x0101, opt, x, y, col, bcol[20], dummy[24], dummy[28], len, str...
	optによって、x, yがofs:selになる
	opt8-10 : 0, 1, 2, 4(3) (0以外はRAM描画, dmy[24]がラインバイト)
	opt11 : extフラグ, strをfar-ptrにする(でも価値無しだな)
	opt12 : col無効化フラグに
	opt13 : bcol無効化フラグ
	opt14-15 : pset, and, or, xor
	とりあえず、opt:0x0100のみのサポートを追加しよう。
	optで関数のアドレスが決まり、それをループごとに呼ぶ。jmpでもよい。
*/
	if (EAX != 0x0100)
		goto error;
	PUSH(DS);
	EBP = cmd[24];
	LDS(ESI, cmd[8]);
	ECX = cmd[32]; /* len */
	DL = cmd[16]; /* col */
	DH = cmd[20]; /* bcol */
	(offset) cmd += 36;
	do {
		PUSH(ECX);
		PUSH(ESI);
		EDI = *cmd;
		(offset) cmd += 4;
		CL = 16;
		do {
			CH = [ES:EDI];
			EDI++;
			TEST(CH, 0x80);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI] = AL;
			TEST(CH, 0x40);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 1] = AL;
			TEST(CH, 0x20);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 2] = AL;
			TEST(CH, 0x10);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 3] = AL;
			TEST(CH, 0x08);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 4] = AL;
			TEST(CH, 0x04);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 5] = AL;
			TEST(CH, 0x02);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 6] = AL;
			TEST(CH, 0x01);
			AL = DL;
			if (== 0)
				AL = DH;
			[DS:ESI + 7] = AL;
			ESI += EBP;
			CL--;
		} while (!= 0);
		POP(ESI);
		POP(ECX);
		ESI += 8;
		ECX--;
	} while (!= 0);
	POP(DS);
	asmout("JMP next_command");

error:
	INT(0x03);
}

void init_mousecursor()
{
	unsigned char *cursor0 == GS:ESI; /* [y][x] */
	int *cursor_buf == DS:EDI;
	GAPI_WORK *work == DS:0x0000;

	PUSH(DS);
	PUSH(ES);
	POP(DS); /* DS == work */

	LEA((offset) cursor_buf, work->mouse_pattern[0]);

	CH = 16 * 2;
	do {
		/* 1loop当たり、1/2line */
		CL = 0x80;
		do {
			EAX = 0x00ffffff;
			EDX = 0;
			TEST(cursor0[ 0], CL); /* black */
			if (!= 0)
				EAX = 0;
			TEST(cursor0[32], CL); /* white */
			if (!= 0) {
				EAX = 0;
				EDX = 0x00ffffff;
			}
			cursor_buf[0] = EAX;
			cursor_buf[4] = EDX;
			(offset) cursor_buf += 8;
			(unsigned char) CL /= 2;
		} while (!= 0);
		(offset) cursor0++;
		CH--;
	} while (!= 0);

	POP(DS);
	return;
}

void GAPI_init()
{
	int all_sel == 1 * 8;
	int *cmd == FS:EBX;

	cmd[4] = 0xffffffff; /* 終了 */
	(offset) cmd += 12;

	GAPI_WORK *workES == ES:0x0000;

	ECX = 0;
	workES->mx1 = 0x80000000; /* 非表示 */
	workES->lockcount = /* 0 */ ECX;
	workES->mouselock = /* 0 */ ECX;
	workES->VGA_mode = /* 0 */ ECX;
	workES->mouseflag = /* 0 */ CL;

	asmout("JMP next_command");
}

void GAPI_resetdevice()
{
	GAPI_WORK *work == ES:0x0000;
	int *cmd == FS:EBX;

	if (cmd[8] == 0x0020) {
		/* 解像度伝達 */
		EAX = cmd[12];
		ECX = cmd[16];
		work->x2 = EAX;
		work->y2 = ECX;
		EAX *= 4;
		work->linebytes = EAX;
		(offset) cmd += 20;
		asmout("JMP next_command");
	}

	// パレット初期化

	cmd[4] = 0xffffffff; // 終了
	(offset) cmd += 12;
	asmout("JMP next_command");

#if 0
palette_table: // Red, Green, Blue
	// 0:黒, 7:暗い灰色, 8:明るい灰色, 6:バックの色, 15:白

	asmout("DB 000H, 000H, 000H,   084H, 000H, 000H,   000H, 084H, 000H,   084H, 084H, 000H");
	asmout("DB 000H, 000H, 084H,   084H, 000H, 084H,   000H, 084H, 084H,   084H, 084H, 084H");
	asmout("DB 0C6H, 0C6H, 0C6H,   0FFH, 000H, 000H,   000H, 0FFH, 000H,   0FFH, 0FFH, 000H");
	asmout("DB 000H, 000H, 0FFH,   0FFH, 000H, 0FFH,   000H, 0FFH, 0FFH,   0FFH, 0FFH, 0FFH");

	color 0-3 : 0x0000, 0x8000, 0x0420, 0x8420
	color 4-7 : 0x0010, 0x8010, 0x0430, 0x8430
	color 8-b : 0xc638, 0xf800, 0x07e0, 0xffe0
	color c-f : 0x001f, 0xf81f, 0x07ff, 0xffff

#endif
}

void GAPI_putmouse()
/* 破壊レジスタ：EAX, ECX, EDX, ESI, EDI */
{
	GAPI_WORK *work == ES:0x0000;
	int *b /* backup */ == ES:EDX, *p /* cursor */ == DS:ESI, *q /* pattern */ == ES:EDI;

	LEA((offset) b, work->backup_buf[0]);
	(offset) p = work->cursor_addr;
	(offset) q = work->pattern_addr;
	PUSH(EBP);
	CH = work->mouse_height;
	EBP = work->linebytes;
	work->mouseflag = 1;
	if (CH == 0)
		goto skip;
	if (work->mouse_width == 16) {
		PUSH(EBX);
		do {
			CL = 2;
			do {
				EAX =  p[ 0]; EBX =  p[ 4];
				b[ 0] =  EAX; b[ 4] =  EBX;
				EAX &= q[ 0]; EBX &= q[ 8];
				EAX ^= q[ 4]; EBX ^= q[12];
				p[ 0] =  EAX; p[ 4] =  EBX;

				EAX =  p[ 8]; EBX =  p[12];
				b[ 8] =  EAX; b[12] =  EBX;
				EAX &= q[16]; EBX &= q[24];
				EAX ^= q[20]; EBX ^= q[28];
				p[ 8] =  EAX; p[12] =  EBX;

				EAX =  p[16]; EBX =  p[20];
				b[16] =  EAX; b[20] =  EBX;
				EAX &= q[32]; EBX &= q[40];
				EAX ^= q[36]; EBX ^= q[44];
				p[16] =  EAX; p[20] =  EBX;

				EAX =  p[24]; EBX =  p[28];
				b[24] =  EAX; b[28] =  EBX;
				EAX &= q[48]; EBX &= q[56];
				EAX ^= q[52]; EBX ^= q[60];
				p[24] =  EAX; p[28] =  EBX;
				(offset) b += 32;
				(offset) p += 32;
				(offset) q += 64;
				CL--;
			} while (!= 0);
			LEA((offset) p, [ESI + EBP - 64]);
			CH--;
			} while (!= 0);
		POP(EBX);
		POP(EBP);
		return;
	}
	do {
		CL = work->mouse_width;
		PUSH((offset) q);
		PUSH((offset) p);
		do {
			EAX = *p;
			*b = EAX;
			EAX &= q[0];
			(offset) b += 4;
			EAX ^= q[4];
			(offset) q += 8;
			*p = EAX;
			(offset) p += 4;
			CL--;
		} while (!= 0);
		POP((offset) p);
		POP((offset) q);
		(offset) p += EBP;
		(offset) q += 128;
		CH--;
	} while (!= 0);
skip:
	POP(EBP);
	return;
}

void GAPI_removemouse()
/* 破壊レジスタ：EAX, ECX, EDX, ESI, EDI */
{
	G