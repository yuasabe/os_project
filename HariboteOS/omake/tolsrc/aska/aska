---------------------------------------------------------------------
                  C言語型アセンブラ"ASKA" Ver1.0β18
---------------------------------------------------------------------
制作日：2001/10/01
制作者：shoe16(shoe16@wizard.elec.waseda.ac.jp)
総指揮：川合堂
修正日：2001/12/06
修正者：RisaPapa(ringring@zb4.so-net.ne.jp)

１．ASKAとは

　従来型アセンブラの記述を、１文＝１命令を守りつつC言語になるべく近づ
けようという構想の下に生まれたものがASKAです。
　従来、アセンブラではif文やloop文などでは不必要にラベルが増えてしま
い管理が非常に大変でした。また構造体が貧弱なため、きちんとしたデータ
型を見通しよくサポートするのが非常に困難でした。さらに、アセンブラは
フリースタイル型の言語ではないために１行に１命令となり行数が非常に多
くなってプログラムの見通しが悪くなっていました。
　このような問題に対処するべく、開発されたのがASKAというわけです。



２．ASKAの使い方

　DOSのコマンドプロンプト上から

	ASKA 入力ファイル名 出力ファイル名

とすると入力ファイルをコンパイルして386ASM形式の出力ファイルを生成し
ます。出力ファイルを省略こともできます。その場合、入力ファイル名が
"sample.ask"ならば出力ファイル名は"sample.asm"になります。

例：
	C:¥ASKA¥WORK¥>ASKA sample.ask sample.asm
	C:¥ASKA¥WORK¥>ASKA sample.ask


重要：コマンドプロンプトのプロパティ（command.comのショートカットの
　　　プロパティ）のメモリ−プロテクトモード(DPMI)メモリの合計を自動
　　　でなくて1024などにしてください。自動のままだと動きません。


３．ASKAの特徴的な機能

　ASKAでは、

・if〜else〜、loop〜break、for、while、do〜while、continueが使えます。
・char、short、long、byte、word、dwordで変数宣言が出来ます。
・関数内でstaticキーワードを使うことで静的な変数が宣言できます。
・関数は戻り値、引数なしのvoid funcname();で宣言が出来ます。
・式文には=、+=、-=、*=、/=、&=、|=、^=、<<=、>>=、=-、=‾、が使えます。
・比較式には==、!=、<、<=、>、>=、が使えます。
・構造体による型定義が使えます。
・ポインタや配列も使えます。
・segmentによるセグメント定義もきちんと出来ます。
・現バージョンのASKAで補いきれていない386ASM本来のニーモニック命令も
　「asmkeyword(list, ...);」でサポート。
・上記で出来ない".386p"などはasmout(".386p");でサポート。
・エイリアスというレジスタを変数に割り当てて使う事が出来ます。
・ローカル変数が定義できます。

　逆に、ASKAでは、

・ラベルの前方参照が出来ません。
・関数に引数を持たせることが出来ません。



４．簡易言語仕様

・インクルード
	include "ファイル名"
とすることでファイルを読み込むことが出来ます。
　また、includeの代わりに#includeでも同じ動作をします。


・コメント
	// コメント文
とする事で//以降、改行が現れるまでの文がコメントアウトされます。これ
らのコメント文は切り捨てられます。
　また、C言語っぽく/* 〜 */もサポートしました。ただ、ネストが効くように
組んであるので注意が必要です。


・式のパラメータ
　式のパラメータはレジスタ(r)、メモリ参照(m)、即値(i)の３種類がありま
す。それぞれ、
	r:EAX, CX, DS, CR0
	m:data, data[0], [EAX], [DS:EAX+EBX*2+&data+‾3], *(EAX+1)
	i:0xffff,-1,100,0b0011,&DATA,sizeof(TYPE),
などのようにかけます。また、変数やメモリ参照のデータ型を一時的に変え
たり定義する場合にはキャストを使うことが出来ます。

※ここにキャスト関係、即値演算関係、[]内記述方式関係を書く


・式文
　式文は
	rm  = rmi;	→	MOV	rm,rmi
			→	MOVSX or MOVZX	(サイズが違うとき)
	r   =   0;	→	XOR	r ,r
	rm += rmi;	→	ADD	rm,rmi
	rm +=   1;	→	INC	rm
	rm -= rmi;	→	SUB	rm,rmi
	rm -=   1;	→	DEC	rm
	rm *=   1;	→	最適化により省略
	reg*=   2;	→	ADD	reg,reg
	rm *=   2;	→	SHL	rm,2
	r32*=   3;	→	LEA	r32,[r32 * 2 + r32]
	rm *=   4;	→	SHL	rm,2
	r32*=   5;	→	LEA	r32,[r32 * 4 + r32]
	rm *=   8;	→	SHL	rm,3
	r32*=   9;	→	LEA	r32,[r32 * 8 + r32]
	rm *=   1;	→	最適化により省略
	rm *=   2;	→	SAR	rm,1	(unsignedの時はSHR)
	rm *=   4;	→	SAR	rm,2	(unsignedの時はSHR)
	rm *=   8;	→	SAR	rm,4	(unsignedの時はSHR)
	rm &= rmi;	→	AND	rm,rmi
	rm |= rmi;	→	OR	rm,rmi
	rm ^= rmi;	→	XOR	rm,rmi
	rm<<= rmi;	→	SAL	rm,rmi	(unsignedの時はSHL)
	reg<<=  1;	→	ADD	reg,reg
	rm>>= rmi;	→	SAR	rm,rmi	(unsignedの時はSHR)
	rm =- rmi;	→	NEG	rm
	rm =‾ rmi;	→	NOT